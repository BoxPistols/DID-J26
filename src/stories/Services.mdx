{/* Services.mdx */}
import { Meta } from '@storybook/blocks'

<Meta title="API/Services" />

# Services API

## AirportService

日本国内の空港データと飛行制限区域を提供します。

### 背景知識：空港周辺の飛行規制

日本の空港周辺には **航空法** に基づく飛行制限区域が設定されています。これに加えて **小型無人機等飛行禁止法** により、指定された空港周辺300m以内の飛行が禁止されています。

<table>
  <thead>
    <tr>
      <th>規制の種類</th>
      <th>根拠法</th>
      <th>対象</th>
      <th>規制内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>航空法</td>
      <td>航空法第132条</td>
      <td>全空港</td>
      <td>空港周辺の設定区域</td>
    </tr>
    <tr>
      <td>小型無人機等飛行禁止法</td>
      <td>国会議事堂等周辺地域の上空における小型無人機等の飛行禁止法</td>
      <td>指定空港</td>
      <td>敷地上空および周辺300m</td>
    </tr>
  </tbody>
</table>

### 使用例

```typescript
import { AirportService } from 'japan-drone-map'

// 全空港を取得
const airports = AirportService.getAll()

// 空港IDで取得
const narita = AirportService.getById('narita')

// 飛行制限区域のGeoJSONを取得
const restrictionZone = AirportService.getRestrictionZone('narita')

// 近くの空港を検索
const nearbyAirports = AirportService.findNearby(35.6762, 139.6503, 50) // 50km以内

// 飛行禁止法指定空港を取得
const designatedAirports = AirportService.getDesignatedAirports()
```

### API詳細

#### getAll()

**シグネチャ**
```typescript
static getAll(): Airport[]
```

**説明**  
日本国内の全空港データを取得します。データはメモリ上でキャッシュされるため、複数回呼び出しても効率的です。

**戻り値**
- `Airport[]` - 全空港の配列（約100施設）

**計算量**  
O(1) - キャッシュから返却

**例外**  
ネットワークエラーの可能性なし（ローカルデータ）

**例**
```typescript
const airports = AirportService.getAll()
console.log(`日本には${airports.length}の空港があります`)

// フィルタリング：国際空港のみ
const intlAirports = airports.filter(a => a.type === 'international')
```

---

#### getById(id: string)

**シグネチャ**
```typescript
static getById(id: string): Airport | null
```

**説明**  
空港IDから特定の空港データを取得します。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>型</th>
      <th>説明</th>
      <th>例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>string</td>
      <td>空港の一意識別子</td>
      <td>'narita', 'haneda', 'kansai'</td>
    </tr>
  </tbody>
</table>

**戻り値**
- `Airport` - マッチした空港データ
- `null` - 該当する空港がない場合

**計算量**  
O(1) - ハッシュマップルックアップ

**例**
```typescript
const narita = AirportService.getById('narita')
if (narita) {
  console.log(`${narita.name}: 標高 ${narita.elevation}m`)
} else {
  console.error('空港が見つかりません')
}
```

---

#### findNearby(lat: number, lng: number, radiusKm: number)

**シグネチャ**
```typescript
static findNearby(lat: number, lng: number, radiusKm: number): Airport[]
```

**説明**  
指定座標から一定範囲内の空港を検索します。距離計算は Haversine 公式を使用しています。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>型</th>
      <th>範囲</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lat</td>
      <td>number</td>
      <td>-90 ～ 90</td>
      <td>緯度（WGS84）</td>
    </tr>
    <tr>
      <td>lng</td>
      <td>number</td>
      <td>-180 ～ 180</td>
      <td>経度（WGS84）</td>
    </tr>
    <tr>
      <td>radiusKm</td>
      <td>number</td>
      <td>> 0</td>
      <td>検索半径（キロメートル）</td>
    </tr>
  </tbody>
</table>

**戻り値**
- `Airport[]` - 範囲内の空港配列（距離でソート）

**計算量**  
O(n) - 全空港との距離計算が必要

**例外**
```typescript
// 無効な座標
findNearby(91, 180, 50) // Error: 無効な緯度
findNearby(35, 181, 50) // Error: 無効な経度
```

**パフォーマンス**  
約100施設の空港データに対して < 1ms

**例**
```typescript
try {
  // 東京周辺50km以内の空港
  const tokyo = { lat: 35.6762, lng: 139.6503 }
  const nearby = AirportService.findNearby(tokyo.lat, tokyo.lng, 50)
  
  nearby.forEach(airport => {
    console.log(`${airport.name}: ${airport.restrictionRadius}km制限`)
  })
} catch (error) {
  console.error('座標エラー:', error.message)
}
```

---

#### getRestrictionZone(airportId: string)

**シグネチャ**
```typescript
static getRestrictionZone(airportId: string): GeoJSON.FeatureCollection | null
```

**説明**  
空港周辺の飛行制限区域をGeoJSON形式で取得します。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>型</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>airportId</td>
      <td>string</td>
      <td>空港ID</td>
    </tr>
  </tbody>
</table>

**戻り値**
- `GeoJSON.FeatureCollection` - 制限区域のポリゴン
- `null` - 空港が見つからない場合

**GeoJSONプロパティ**
```typescript
{
  type: 'FeatureCollection',
  features: [{
    type: 'Feature',
    properties: {
      airportId: 'narita',
      airportName: '成田国際空港',
      radiusKm: 9.26,
      restrictionType: 'aviation-law' | 'drone-law'
    },
    geometry: { type: 'Polygon', coordinates: [...] }
  }]
}
```

**例**
```typescript
const geoJson = AirportService.getRestrictionZone('haneda')
if (geoJson) {
  // MapLibreで表示
  map.addSource('airport-zone', { type: 'geojson', data: geoJson })
  map.addLayer({
    id: 'airport-zone-fill',
    type: 'fill',
    source: 'airport-zone',
    paint: { 'fill-color': '#90EE90', 'fill-opacity': 0.3 }
  })
}
```

---

#### getDesignatedAirports()

**シグネチャ**
```typescript
static getDesignatedAirports(): Airport[]
```

**説明**  
小型無人機等飛行禁止法に指定されている空港のみを取得します。

**戻り値**
- `Airport[]` - 指定空港の配列

**重要施設指定空港（2026年現在）**
- 成田国際空港
- 羽田空港
- 関西国際空港
- 中部国際空港
- 福岡空港
- その他主要国際空港

**例**
```typescript
const designatedAirports = AirportService.getDesignatedAirports()
console.log(`${designatedAirports.length}の空港が法律対象です`)

// 飛行計画時にチェック
const isNearDesignated = (lat, lng, radiusKm) => {
  const nearbyDesignated = designatedAirports
    .filter(a => calculateDistance(lat, lng, a.coordinates) < radiusKm)
  return nearbyDesignated.length > 0
}
```

### 空港データ構造

```typescript
interface Airport {
  id: string                          // 空港識別子
  name: string                        // 日本語名
  nameEn: string                      // 英語名
  type: 'international' | 'domestic' | 'military' | 'heliport'
  coordinates: [number, number]       // [経度, 緯度] WGS84
  elevation: number                   // 標高（メートル）
  runways: number                     // 滑走路数
  restrictionRadius: number           // 飛行制限半径（km）
  isDesignatedUnderLaw: boolean       // 小型無人機等飛行禁止法対象
}
```

### ベストプラクティス

#### 1. 飛行可能性の事前確認

```typescript
function canFlyAtLocation(lat: number, lng: number): boolean {
  try {
    // 指定座標の10km範囲内の空港チェック
    const nearbyAirports = AirportService.findNearby(lat, lng, 10)
    
    if (nearbyAirports.length === 0) {
      return true // 空港がない = 飛行可能の可能性
    }
    
    // 指定空港の制限区域チェック
    for (const airport of nearbyAirports) {
      const zone = AirportService.getRestrictionZone(airport.id)
      if (zone && isPointInPolygon(lat, lng, zone)) {
        return false // 制限区域内
      }
    }
    
    return true
  } catch (error) {
    console.error('飛行可能性チェック失敗:', error)
    return false // エラー時は安全側
  }
}
```

#### 2. キャッシングの活用

```typescript
// ❌ 避けるべき：毎回全データ取得
for (let i = 0; i < 1000; i++) {
  const airports = AirportService.getAll() // 不要な処理
}

// ✅ 推奨：一度取得してメモリに保持
const allAirports = AirportService.getAll()
for (const airport of allAirports) {
  processAirport(airport)
}
```

#### 3. エラーハンドリング

```typescript
function safeGetAirportData(airportId: string): Airport | null {
  try {
    const airport = AirportService.getById(airportId)
    if (!airport) {
      console.warn(`空港 '${airportId}' が見つかりません`)
      return null
    }
    return airport
  } catch (error) {
    console.error(`空港データ取得エラー: ${error.message}`)
    return null
  }
}
```

### 実践例：飛行計画システム

```typescript
interface FlightPlan {
  startPoint: [number, number]
  endPoint: [number, number]
  isValid: boolean
  warnings: string[]
}

function validateFlightPlan(
  startLat: number,
  startLng: number,
  endLat: number,
  endLng: number
): FlightPlan {
  const warnings: string[] = []
  
  // 1. 出発地点の空港チェック
  const departureNearby = AirportService.findNearby(startLat, startLng, 5)
  if (departureNearby.length > 0) {
    warnings.push(`出発地が ${departureNearby[0].name} の近くです`)
  }
  
  // 2. 到着地点の空港チェック
  const arrivalNearby = AirportService.findNearby(endLat, endLng, 5)
  if (arrivalNearby.length > 0) {
    warnings.push(`到着地が ${arrivalNearby[0].name} の近くです`)
  }
  
  // 3. 指定空港チェック
  const designated = AirportService.getDesignatedAirports()
  const nearDesignated = designated.filter(
    a => AirportService.findNearby(a.coordinates[1], a.coordinates[0], 10).length > 0
  )
  
  return {
    startPoint: [startLng, startLat],
    endPoint: [endLng, endLat],
    isValid: warnings.length === 0,
    warnings
  }
}
```

---

## NoFlyZoneService

小型無人機等飛行禁止法に基づく飛行禁止区域を提供します。

### 法的背景

**小型無人機等飛行禁止法** は2015年に制定され、国の重要施設周辺でドローンの飛行を禁止しています。

#### ゾーン定義

<table>
  <thead>
    <tr>
      <th>ゾーン</th>
      <th>正式名称</th>
      <th>範囲</th>
      <th>規制</th>
      <th>根拠</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Red</td>
      <td>敷地・区域の上空</td>
      <td>施設敷地そのもの</td>
      <td>完全禁止</td>
      <td>法律第3条</td>
    </tr>
    <tr>
      <td>Yellow</td>
      <td>周辺区域の上空</td>
      <td>敷地周辺約300m</td>
      <td>事前通報で許可</td>
      <td>法律第4条</td>
    </tr>
  </tbody>
</table>

#### 対象施設カテゴリ

<table>
  <thead>
    <tr>
      <th>カテゴリ</th>
      <th>法的根拠</th>
      <th>数</th>
      <th>備考</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>government</td>
      <td>国会議事堂等周辺地域の上空における小型無人機等の飛行禁止法 第3条</td>
      <td>~30</td>
      <td>国会、官邸、皇居など</td>
    </tr>
    <tr>
      <td>nuclear</td>
      <td>原子力施設周辺</td>
      <td>20</td>
      <td>すべて法指定対象</td>
    </tr>
    <tr>
      <td>military</td>
      <td>防衛施設法</td>
      <td>~40</td>
      <td>自衛隊・米軍基地</td>
    </tr>
    <tr>
      <td>foreign_mission</td>
      <td>外交関係処遇条約</td>
      <td>~50</td>
      <td>大使館・公使館</td>
    </tr>
    <tr>
      <td>airport</td>
      <td>航空法・飛行禁止法</td>
      <td>~20</td>
      <td>指定国際空港</td>
    </tr>
  </tbody>
</table>

**2026年の改正予定**：イエローゾーン範囲が300m → 1kmに拡大予定

### 使用例

```typescript
import { NoFlyZoneService } from 'japan-drone-map'

// 全ての飛行禁止区域を取得
const allZones = NoFlyZoneService.getAll()

// 赤エリア（飛行禁止）のみ取得
const redZones = NoFlyZoneService.getByType('red')

// 黄エリア（注意区域）のみ取得
const yellowZones = NoFlyZoneService.getByType('yellow')

// カテゴリで取得
const nuclearPlants = NoFlyZoneService.getByCategory('nuclear')
const embassies = NoFlyZoneService.getByCategory('foreign_mission')

// GeoJSON形式で取得
const geoJson = NoFlyZoneService.toGeoJSON()
```

### API詳細

#### getAll()

**戻り値** `NoFlyZone[]` - 日本全国の飛行禁止区域（約150+施設）

**計算量** O(1) - キャッシュ取得

**データ統計（2026年）**
- 国家重要施設：~30施設
- 原子力発電所：20施設
- 防衛施設：~40施設
- 外国公館：~50施設

**例**
```typescript
const allZones = NoFlyZoneService.getAll()
console.log(`日本に${allZones.length}の飛行禁止区域があります`)

// レッド/イエロー集計
const redCount = allZones.filter(z => z.type === 'red').length
const yellowCount = allZones.filter(z => z.type === 'yellow').length
console.log(`レッド: ${redCount}, イエロー: ${yellowCount}`)
```

---

#### getByType(type: 'red' | 'yellow')

**パラメータ**
<table>
  <thead>
    <tr>
      <th>値</th>
      <th>意味</th>
      <th>規制</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>'red'</td>
      <td>敷地上空</td>
      <td>完全飛行禁止</td>
    </tr>
    <tr>
      <td>'yellow'</td>
      <td>周辺300m</td>
      <td>事前通報で飛行可能</td>
    </tr>
  </tbody>
</table>

**計算量** O(n)

**例**
```typescript
const redZones = NoFlyZoneService.getByType('red')
const yellowZones = NoFlyZoneService.getByType('yellow')

console.log(`完全禁止: ${redZones.length}, 許可可能: ${yellowZones.length}`)
```

---

#### getByCategory(category)

**対象カテゴリ**
```typescript
type NoFlyCategory = 
  | 'government'        // 国家重要施設
  | 'nuclear'           // 原子力発電所
  | 'military'          // 防衛関係施設
  | 'foreign_mission'   // 外国公館
  | 'airport'           // 指定空港
```

**例**
```typescript
// 原子力施設周辺
const nuclearZones = NoFlyZoneService.getByCategory('nuclear')
console.log(`${nuclearZones.length}の原発周辺に禁止区域`)

// 外国公館周辺
const embassies = NoFlyZoneService.getByCategory('foreign_mission')
embassies.forEach(zone => {
  console.log(`${zone.name}: ${zone.type}ゾーン`)
})
```

---

#### toGeoJSON()

**戻り値** `GeoJSON.FeatureCollection` - MapLibre表示用

**プロパティ例**
```typescript
{
  properties: {
    id: 'diet-red',
    name: '国会議事堂',
    type: 'red',
    category: 'government',
    description: '...'
  }
}
```

**データサイズ**
- JSON：~15MB
- 展開時：~20MB

**MapLibre表示例**
```typescript
const geoJson = NoFlyZoneService.toGeoJSON()

map.addSource('no-fly-zones', {
  type: 'geojson',
  data: geoJson
})

// レッドゾーン
map.addLayer({
  id: 'red-zones',
  type: 'fill',
  source: 'no-fly-zones',
  filter: ['==', ['get', 'type'], 'red'],
  paint: {
    'fill-color': '#FF0000',
    'fill-opacity': 0.3
  }
})

// イエローゾーン
map.addLayer({
  id: 'yellow-zones',
  type: 'fill',
  source: 'no-fly-zones',
  filter: ['==', ['get', 'type'], 'yellow'],
  paint: {
    'fill-color': '#FFFF00',
    'fill-opacity': 0.2
  }
})
```

### ベストプラクティス

#### 1. 飛行許可申請の確認

```typescript
function checkFlightPermission(
  lat: number, 
  lng: number
): { canFly: boolean; requiresPermission: boolean; location?: string } {
  const allZones = NoFlyZoneService.getAll()
  
  for (const zone of allZones) {
    if (isPointInZone(lat, lng, zone)) {
      if (zone.type === 'red') {
        return { canFly: false, requiresPermission: false }
      } else if (zone.type === 'yellow') {
        return { 
          canFly: true, 
          requiresPermission: true, 
          location: zone.name 
        }
      }
    }
  }
  
  return { canFly: true, requiresPermission: false }
}
```

#### 2. エラーハンドリング

```typescript
async function fetchNoFlyZonesWithRetry(maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return NoFlyZoneService.getAll()
    } catch (error) {
      if (i === maxRetries - 1) throw error
      console.warn(`リトライ ${i + 1}/${maxRetries}`)
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)))
    }
  }
}
```

### 実践例：飛行可能エリア検索

```typescript
function findNearestAvailableArea(
  centerLat: number,
  centerLng: number,
  searchRadiusKm: number = 5
): { available: boolean; message: string; alternativeLocations?: string[] } {
  const zones = NoFlyZoneService.getAll()
  const redZones = zones.filter(z => z.type === 'red')
  
  // 指定座標がレッドゾーン内か確認
  const inRedZone = redZones.some(zone => 
    isPointInZone(centerLat, centerLng, zone)
  )
  
  if (!inRedZone) {
    return { available: true, message: 'この場所は飛行可能です' }
  }
  
  // 代替地点を検索
  const alternativeLocations = redZones
    .filter(zone => {
      const dist = calculateDistance(centerLat, centerLng, zone.coordinates)
      return dist < searchRadiusKm
    })
    .map(zone => `${zone.name}から${zone.radiusKm}km外側`)
  
  return {
    available: false,
    message: 'この場所は飛行禁止です',
    alternativeLocations
  }
}
```

### 区域の種類

<table>
  <thead>
    <tr>
      <th>タイプ</th>
      <th>説明</th>
      <th>例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>red</td>
      <td>完全飛行禁止</td>
      <td>国会議事堂、首相官邸、皇居、原子力発電所</td>
    </tr>
    <tr>
      <td>yellow</td>
      <td>注意区域・要許可</td>
      <td>外国大使館周辺</td>
    </tr>
  </tbody>
</table>

### 区域データ構造

```typescript
interface NoFlyZone {
  id: string
  name: string
  type: 'red' | 'yellow'
  category: 'government' | 'nuclear' | 'embassy' | 'military' | 'other'
  coordinates: [number, number]
  radiusKm: number
  description?: string
}
```

---

## RainViewerService

RainViewer APIを使用した雨雲レーダー機能を提供します。

### 背景知識：気象データの重要性

ドローンの飛行安全性は気象条件に大きく左右されます。特に以下の点が重要です：

- **降雨**：バッテリー消耗の加速、機体の浸水リスク
- **積雲**：視程制限、衝突リスク
- **風**：機体の安定性低下、飛行不可になる可能性
- **気圧**：高度計の精度に影響

RainViewer APIは世界規模の気象レーダーデータをタイル形式で提供し、リアルタイムの降雨状況を可視化できます。

### 使用例

```typescript
import { RainViewerService } from 'japan-drone-map'

// 利用可能なレーダーフレームを取得
const frames = await RainViewerService.getAvailableFrames()

// 最新のタイルURLを取得
const latestTile = RainViewerService.buildTileUrl(
  frames.radar.past[frames.radar.past.length - 1].path
)

// アニメーション用の全フレームURL
const animationUrls = frames.radar.past.map(frame =>
  RainViewerService.buildTileUrl(frame.path)
)

// MapLibreで降雨レイヤーを表示
map.addSource('rainviewer', {
  type: 'raster',
  tiles: [latestTile],
  tileSize: 256
})

map.addLayer({
  id: 'rainviewer-layer',
  type: 'raster',
  source: 'rainviewer',
  paint: { 'raster-opacity': 0.6 }
})
```

### API詳細

#### getAvailableFrames()

**シグネチャ**
```typescript
static async getAvailableFrames(): Promise<RainViewerData>
```

**説明**  
RainViewer APIから利用可能なレーダーフレーム一覧を取得します。過去フレーム（過去6時間）と予報フレーム（今後1-2時間）が含まれます。

**戻り値**
- `RainViewerData` - フレーム情報を含むデータ構造
  - `radar.past`: 過去のレーダーフレーム（約1時間ごと）
  - `radar.nowcast`: 短時間予報フレーム（15分～1時間先）

**計算量**  
O(1) - API呼び出し1回

**パフォーマンス**  
ネットワーク依存（通常 200-500ms）

**例外**
```typescript
try {
  const frames = await RainViewerService.getAvailableFrames()
} catch (error) {
  if (error.message.includes('404')) {
    console.error('RainViewer APIに接続できません')
  } else {
    console.error('ネットワークエラー:', error.message)
  }
}
```

**例**
```typescript
const frames = await RainViewerService.getAvailableFrames()
console.log(`過去フレーム：${frames.radar.past.length}件`)
console.log(`予報フレーム：${frames.radar.nowcast.length}件`)

// 最新フレームの時刻を取得
const latestTime = frames.radar.past[frames.radar.past.length - 1].time
console.log(`最新レーダー：${new Date(latestTime * 1000).toLocaleString('ja-JP')}`)
```

---

#### buildTileUrl(path: string)

**シグネチャ**
```typescript
static buildTileUrl(path: string): string
```

**説明**  
RainViewer フレームパスからMapLibre互換のタイルURLを生成します。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>型</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>path</td>
      <td>string</td>
      <td>RainViewer APIから取得したフレームパス（例：'/v5/weather/radar/1704067200'）</td>
    </tr>
  </tbody>
</table>

**戻り値**
- `string` - MapLibre GeoJSONタイルURL（形式：`https://tilecache.rainviewer.com/...`）

**計算量**  
O(1) - 文字列処理

**例**
```typescript
const frames = await RainViewerService.getAvailableFrames()
const latestFrame = frames.radar.past[frames.radar.past.length - 1]
const tileUrl = RainViewerService.buildTileUrl(latestFrame.path)

// URL形式例：
// https://tilecache.rainviewer.com/v5/weather/radar/1704067200/512/{z}/{x}/{y}/8
```

---

### フレームデータ構造

```typescript
interface RainViewerFrame {
  time: number // Unix timestamp (秒単位)
  path: string // API パス (/v5/weather/radar/...)
}

interface RainViewerData {
  radar: {
    past: RainViewerFrame[]      // 過去フレーム（6時間分）
    nowcast: RainViewerFrame[]   // 予報フレーム（1-2時間先）
  }
}
```

### ベストプラクティス

#### 1. キャッシングとリフレッシュ

```typescript
class CachedRainViewerClient {
  private cachedFrames: RainViewerData | null = null
  private cacheTime: number = 0
  private CACHE_DURATION = 5 * 60 * 1000 // 5分

  async getFrames(): Promise<RainViewerData> {
    const now = Date.now()
    
    // キャッシュが有効か確認
    if (this.cachedFrames && (now - this.cacheTime) < this.CACHE_DURATION) {
      return this.cachedFrames
    }
    
    // 新鮮なフレームを取得
    this.cachedFrames = await RainViewerService.getAvailableFrames()
    this.cacheTime = now
    return this.cachedFrames
  }

  getLatestTile(): string {
    if (!this.cachedFrames) throw new Error('フレームデータが利用できません')
    const latestFrame = this.cachedFrames.radar.past[
      this.cachedFrames.radar.past.length - 1
    ]
    return RainViewerService.buildTileUrl(latestFrame.path)
  }
}
```

#### 2. エラーハンドリング

```typescript
async function fetchRainViewerWithRetry(maxRetries = 3): Promise<RainViewerData> {
  let lastError: Error | null = null
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await RainViewerService.getAvailableFrames()
    } catch (error) {
      lastError = error as Error
      if (i < maxRetries - 1) {
        // 指数バックオフでリトライ
        const delay = Math.pow(2, i) * 1000
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
  }
  
  throw lastError || new Error('RainViewerデータ取得失敗')
}
```

#### 3. アニメーション実装

```typescript
async function animateRainViewer(map: mapboxgl.Map) {
  const frames = await RainViewerService.getAvailableFrames()
  const allFrames = [...frames.radar.past, ...frames.radar.nowcast]
  
  let currentIndex = 0
  const animationInterval = setInterval(() => {
    const frame = allFrames[currentIndex % allFrames.length]
    const tileUrl = RainViewerService.buildTileUrl(frame.path)
    
    // タイルソースを更新
    const source = map.getSource('rainviewer') as mapboxgl.RasterSource
    if (source) {
      source.setTiles([tileUrl])
    }
    
    currentIndex++
  }, 500) // 500ms ごとにフレーム更新
  
  return () => clearInterval(animationInterval)
}
```

### 実践例：飛行可能判定システム

```typescript
interface FlightWeatherCheck {
  canFly: boolean
  rainIntensity: 'none' | 'light' | 'moderate' | 'heavy'
  recommendation: string
  forecastTime?: number
}

async function checkFlightWeather(
  lat: number,
  lng: number,
  checkForecast: boolean = false
): Promise<FlightWeatherCheck> {
  try {
    const frames = await RainViewerService.getAvailableFrames()
    const framesToCheck = checkForecast 
      ? frames.radar.nowcast 
      : [frames.radar.past[frames.radar.past.length - 1]]
    
    // 降雨強度をチェック
    for (const frame of framesToCheck) {
      const tileUrl = RainViewerService.buildTileUrl(frame.path)
      const intensity = await analyzeRainIntensity(tileUrl, lat, lng)
      
      if (intensity === 'heavy') {
        return {
          canFly: false,
          rainIntensity: 'heavy',
          recommendation: '強い降雨のため飛行禁止。1時間後の再確認を推奨。',
          forecastTime: frame.time
        }
      }
      
      if (intensity === 'moderate') {
        return {
          canFly: true,
          rainIntensity: 'moderate',
          recommendation: '中程度の降雨。飛行可能だが注意が必要。バッテリー消費が増加する可能性。',
          forecastTime: frame.time
        }
      }
    }
    
    return {
      canFly: true,
      rainIntensity: 'none',
      recommendation: '良好な天候です。飛行可能。'
    }
  } catch (error) {
    console.error('天候チェック失敗:', error)
    return {
      canFly: false,
      rainIntensity: 'heavy', // エラー時は安全側
      recommendation: 'データを取得できません。天気予報を確認してください。'
    }
  }
}
```

---

## OpenWeatherService

OpenWeatherMap APIとWindy.comを使用した気象データ機能を提供します。

### 背景知識：ドローン飛行と風

ドローン運用の最大のリスク要因は風速です。日本のドローン規制では：

- **3m/s未満**：通常運用可能
- **3-5m/s**：操縦難度が増加、初心者向けではない
- **5-10m/s**：高度なスキル必須、機体性能に依存
- **10m/s以上**：フライアットハイト（農業用途）以外は推奨されない

OpenWeatherMap APIは全球規模の気象予測データを提供し、風速・風向の詳細データが得られます。

### 使用例

```typescript
import { OpenWeatherService } from 'japan-drone-map'

// 現在の天気を取得
const weather = await OpenWeatherService.fetchWeather(35.6762, 139.6503, 'YOUR_API_KEY')
console.log(`気温：${weather.temp}°C、風速：${weather.wind.speed}m/s`)

// 風データのみ取得
const wind = await OpenWeatherService.fetchWind(35.6762, 139.6503, 'YOUR_API_KEY')
console.log(`風向：${wind.direction}°、風速：${wind.speed}m/s`)

// 風速カテゴリを取得
const category = OpenWeatherService.getWindCategory(5.5) // m/s
console.log(`風速レベル：${category.nameJa}（${category.level}）`)

// Windy.com埋め込みURL（リアルタイム風可視化用）
const windyUrl = OpenWeatherService.getWindyEmbed(35.6762, 139.6503, 8)

// タイルベース天気レイヤー（MapLibre用）
const windTileUrl = OpenWeatherService.buildTileUrl('wind_new', 'YOUR_API_KEY')
map.addSource('openweather-wind', {
  type: 'raster',
  tiles: [windTileUrl],
  tileSize: 256
})
```

### API詳細

#### fetchWeather(lat: number, lng: number, apiKey: string)

**シグネチャ**
```typescript
static async fetchWeather(
  lat: number,
  lng: number,
  apiKey: string
): Promise<{
  temp: number
  feelsLike: number
  humidity: number
  pressure: number
  wind: { speed: number; direction: number }
  clouds: number
  description: string
  sunrise: number
  sunset: number
}>
```

**説明**  
OpenWeatherMap APIから指定座標の現在の天気データを取得します。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>型</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lat</td>
      <td>number</td>
      <td>緯度（WGS84、-90～90）</td>
    </tr>
    <tr>
      <td>lng</td>
      <td>number</td>
      <td>経度（WGS84、-180～180）</td>
    </tr>
    <tr>
      <td>apiKey</td>
      <td>string</td>
      <td>OpenWeatherMap APIキー</td>
    </tr>
  </tbody>
</table>

**戻り値**
```typescript
{
  temp: number              // 気温（℃）
  feelsLike: number        // 体感気温（℃）
  humidity: number         // 湿度（0-100%）
  pressure: number         // 気圧（hPa）
  wind: {
    speed: number          // 風速（m/s）
    direction: number      // 風向（0-360°、0=北）
  }
  clouds: number           // 雲量（0-100%）
  description: string      // 天候描写
  sunrise: number          // 日出時刻（Unix timestamp）
  sunset: number           // 日没時刻（Unix timestamp）
}
```

**パフォーマンス**  
API呼び出し（ネットワーク依存）：通常 300-800ms

**例外**
```typescript
try {
  const weather = await OpenWeatherService.fetchWeather(35.6762, 139.6503, apiKey)
} catch (error) {
  if (error.message.includes('401')) {
    console.error('APIキーが無効です')
  } else if (error.message.includes('429')) {
    console.error('API呼び出し制限に達しました')
  }
}
```

**例**
```typescript
const weather = await OpenWeatherService.fetchWeather(35.6762, 139.6503, 'YOUR_KEY')
console.log(`東京の天気：${weather.description}`)
console.log(`気温 ${weather.temp}°C（体感 ${weather.feelsLike}°C）`)
console.log(`風速 ${weather.wind.speed}m/s、風向 ${weather.wind.direction}°`)

// フライト判定
if (weather.wind.speed > 10) {
  console.log('風が強いためフライト不可')
} else if (weather.wind.speed > 5) {
  console.log('風速に注意してフライト可能')
}
```

---

#### fetchWind(lat: number, lng: number, apiKey: string)

**シグネチャ**
```typescript
static async fetchWind(
  lat: number,
  lng: number,
  apiKey: string
): Promise<{
  speed: number
  direction: number
  gust?: number
}>
```

**説明**  
風データに特化したAPI。風速と風向を取得します。

**戻り値**
```typescript
{
  speed: number      // 風速（m/s）
  direction: number  // 風向（0-360°）
  gust?: number      // ガスト（突風）（m/s、オプション）
}
```

**計算量**  
O(1) - API呼び出し1回

**例**
```typescript
const wind = await OpenWeatherService.fetchWind(35.6762, 139.6503, apiKey)
const category = OpenWeatherService.getWindCategory(wind.speed)
console.log(`${category.nameJa}：${category.name}`)
```

---

#### getWindCategory(speedMs: number)

**シグネチャ**
```typescript
static getWindCategory(speedMs: number): {
  level: number
  name: string
  nameJa: string
  color: string
  description: string
}
```

**説明**  
風速（m/s）から風速レベル（ビューフォートスケール）を取得します。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>型</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>speedMs</td>
      <td>number</td>
      <td>風速（m/s）</td>
    </tr>
  </tbody>
</table>

**戻り値**
```typescript
{
  level: number      // レベル（0-5）
  name: string       // 英語名
  nameJa: string     // 日本語名
  color: string      // UIに使用する色（16進数）
  description: string // 風の説明
}
```

**計算量**  
O(1) - 範囲判定のみ

**例**
```typescript
const speeds = [0.5, 2.0, 5.5, 10.0, 15.0, 25.0]
speeds.forEach(speed => {
  const cat = OpenWeatherService.getWindCategory(speed)
  console.log(`${speed}m/s → ${cat.nameJa}（${cat.name}）`)
})
```

---

#### buildTileUrl(layer: string, apiKey: string)

**シグネチャ**
```typescript
static buildTileUrl(
  layer: 'wind_new' | 'temp_new' | 'clouds_new' | 'pressure_new',
  apiKey: string
): string
```

**説明**  
OpenWeatherMap タイルAPIのURLを生成します。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>値</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>wind_new</td>
      <td>風速・風向レイヤー（ドローン運用に重要）</td>
    </tr>
    <tr>
      <td>temp_new</td>
      <td>気温分布レイヤー</td>
    </tr>
    <tr>
      <td>clouds_new</td>
      <td>雲量レイヤー</td>
    </tr>
    <tr>
      <td>pressure_new</td>
      <td>気圧レイヤー</td>
    </tr>
  </tbody>
</table>

**例**
```typescript
const windUrl = OpenWeatherService.buildTileUrl('wind_new', 'YOUR_API_KEY')
map.addSource('openweather-wind', {
  type: 'raster',
  tiles: [windUrl],
  tileSize: 256
})
```

---

#### getWindyEmbed(lat: number, lng: number, zoom: number)

**シグネチャ**
```typescript
static getWindyEmbed(lat: number, lng: number, zoom: number): string
```

**説明**  
Windy.com 埋め込みURLを生成します。リアルタイムの高度な気象可視化が可能です。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>型</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lat</td>
      <td>number</td>
      <td>緯度</td>
    </tr>
    <tr>
      <td>lng</td>
      <td>number</td>
      <td>経度</td>
    </tr>
    <tr>
      <td>zoom</td>
      <td>number</td>
      <td>ズームレベル（1-20）</td>
    </tr>
  </tbody>
</table>

**戻り値**
- `string` - Windy.com iframeコードまたはURL

**例**
```typescript
const windyUrl = OpenWeatherService.getWindyEmbed(35.6762, 139.6503, 8)
// URL例：https://www.windy.com/?35.6762,139.6503,8
```

### 風速カテゴリ（ビューフォート）

<table>
  <thead>
    <tr>
      <th>レベル</th>
      <th>名称</th>
      <th>日本語</th>
      <th>風速 (m/s)</th>
      <th>ドローン運用</th>
      <th>色</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Calm</td>
      <td>静穏</td>
      <td>&lt; 0.5</td>
      <td>最適</td>
      <td style={{backgroundColor: '#00E5FF', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>1</td>
      <td>Light</td>
      <td>軽風</td>
      <td>0.5 - 3.4</td>
      <td>推奨</td>
      <td style={{backgroundColor: '#00E676', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>2</td>
      <td>Moderate</td>
      <td>和風</td>
      <td>3.4 - 7.9</td>
      <td>要注意</td>
      <td style={{backgroundColor: '#FFEB3B', width: '60px', height: '30px', borderRadius: '4px', border: '1px solid #ccc'}}></td>
    </tr>
    <tr>
      <td>3</td>
      <td>Strong</td>
      <td>強風</td>
      <td>7.9 - 13.9</td>
      <td>上級者向け</td>
      <td style={{backgroundColor: '#FF9800', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>4</td>
      <td>Gale</td>
      <td>暴風</td>
      <td>13.9 - 20.8</td>
      <td>不可</td>
      <td style={{backgroundColor: '#F44336', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>5</td>
      <td>Storm</td>
      <td>猛烈な風</td>
      <td>&gt; 20.8</td>
      <td>禁止</td>
      <td style={{backgroundColor: '#9C27B0', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
  </tbody>
</table>

### ベストプラクティス

#### 1. APIキーの安全な管理

```typescript
// ❌ 避けるべき：クライアントに直接記述
const apiKey = 'sk_live_abc123def456'

// ✅ 推奨：環境変数経由
const apiKey = import.meta.env.VITE_OPENWEATHER_API_KEY
if (!apiKey) {
  console.warn('OpenWeather APIキーが設定されていません')
}

// ✅ さらに安全：バックエンド経由
const weather = await fetch('/api/weather?lat=35.6762&lng=139.6503')
```

#### 2. エラーハンドリングとフォールバック

```typescript
async function safeGetWeather(lat: number, lng: number) {
  try {
    return await OpenWeatherService.fetchWeather(lat, lng, apiKey)
  } catch (error) {
    console.warn('OpenWeather APIエラー、フォールバック:', error)
    // 前回キャッシュ、または安全なデフォルト値を使用
    return {
      temp: undefined,
      wind: { speed: Infinity }, // 飛行不可と判定
      description: 'データ取得失敗 - フライト不可'
    }
  }
}
```

#### 3. キャッシング戦略

```typescript
class WeatherCache {
  private cache = new Map<string, { data: any; timestamp: number }>()
  private CACHE_DURATION = 10 * 60 * 1000 // 10分

  async getWeather(lat: number, lng: number, apiKey: string) {
    const key = `${lat},${lng}`
    const cached = this.cache.get(key)
    
    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
      return cached.data
    }
    
    const weather = await OpenWeatherService.fetchWeather(lat, lng, apiKey)
    this.cache.set(key, { data: weather, timestamp: Date.now() })
    return weather
  }

  clear() {
    this.cache.clear()
  }
}
```

### 実践例：気象に基づく飛行計画システム

```typescript
interface FlightWeatherPlan {
  canFly: boolean
  windRisk: 'safe' | 'caution' | 'danger'
  conditions: {
    temperature: number
    windSpeed: number
    windDirection: number
    humidity: number
  }
  recommendations: string[]
  bestTime?: Date
}

async function planFlightByWeather(
  lat: number,
  lng: number,
  apiKey: string
): Promise<FlightWeatherPlan> {
  try {
    const weather = await OpenWeatherService.fetchWeather(lat, lng, apiKey)
    const windCategory = OpenWeatherService.getWindCategory(weather.wind.speed)
    
    const recommendations: string[] = []
    let canFly = true
    let windRisk: 'safe' | 'caution' | 'danger' = 'safe'
    
    // 風速チェック
    if (weather.wind.speed > 10) {
      windRisk = 'danger'
      canFly = false
      recommendations.push('風が強すぎます。飛行は不可能です。')
    } else if (weather.wind.speed > 5) {
      windRisk = 'caution'
      recommendations.push('風速が高めです。上級スキルが必要です。')
    } else {
      windRisk = 'safe'
      recommendations.push('風速は良好です。')
    }
    
    // 湿度チェック
    if (weather.humidity > 80) {
      recommendations.push('湿度が高いため、バッテリー管理に注意してください。')
    }
    
    // 気温チェック
    if (weather.temp < 0) {
      recommendations.push('気温が低いため、バッテリー性能が低下します。')
    } else if (weather.temp > 40) {
      recommendations.push('気温が高すぎるため、機体の過熱に注意してください。')
    }
    
    // 雲量チェック
    if (weather.clouds > 80) {
      recommendations.push('曇りが強いため、視程に注意してください。')
    }
    
    return {
      canFly,
      windRisk,
      conditions: {
        temperature: weather.temp,
        windSpeed: weather.wind.speed,
        windDirection: weather.wind.direction,
        humidity: weather.humidity
      },
      recommendations,
      bestTime: new Date(Date.now() + 2 * 3600000) // 2時間後
    }
  } catch (error) {
    return {
      canFly: false,
      windRisk: 'danger',
      conditions: {
        temperature: NaN,
        windSpeed: NaN,
        windDirection: NaN,
        humidity: NaN
      },
      recommendations: ['気象データを取得できません。天気予報を確認してください。']
    }
  }
}
```

### 風速カテゴリ（ビューフォート）

<table>
  <thead>
    <tr>
      <th>レベル</th>
      <th>名称</th>
      <th>日本語</th>
      <th>風速 (m/s)</th>
      <th>色</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Calm</td>
      <td>静穏</td>
      <td>&lt; 0.5</td>
      <td style={{backgroundColor: '#00E5FF', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>1</td>
      <td>Light</td>
      <td>軽風</td>
      <td>0.5 - 3.4</td>
      <td style={{backgroundColor: '#00E676', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>2</td>
      <td>Moderate</td>
      <td>和風</td>
      <td>3.4 - 7.9</td>
      <td style={{backgroundColor: '#FFEB3B', width: '60px', height: '30px', borderRadius: '4px', border: '1px solid #ccc'}}></td>
    </tr>
    <tr>
      <td>3</td>
      <td>Strong</td>
      <td>強風</td>
      <td>7.9 - 13.9</td>
      <td style={{backgroundColor: '#FF9800', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>4</td>
      <td>Gale</td>
      <td>暴風</td>
      <td>13.9 - 20.8</td>
      <td style={{backgroundColor: '#F44336', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
    <tr>
      <td>5</td>
      <td>Storm</td>
      <td>猛烈な風</td>
      <td>&gt; 20.8</td>
      <td style={{backgroundColor: '#9C27B0', width: '60px', height: '30px', borderRadius: '4px'}}></td>
    </tr>
  </tbody>
</table>

---

## CustomLayerService

ユーザーが独自の地理空間データを管理・可視化できるサービスです。LocalStorageを使用した永続化により、ユーザーが定義したカスタムレイヤーがセッション間で保持されます。

### 背景知識：カスタムレイヤーの用途

ドローン運用では、公式のデータセット以外にも様々な地理情報が必要です：

- **No-Fly Zone追加**：施設周辺の独自禁止区域
- **Point of Interest**：ヘリポート、着陸地点候補
- **Hazard Area**：危険区域（障害物、高圧線など）
- **Route Planning**：飛行経路の可視化
- **Historical Data**：過去のフライト記録

### 使用例

```typescript
import { CustomLayerService } from 'japan-drone-map'

// 全カスタムレイヤーを取得
const allLayers = CustomLayerService.getAll()
console.log(`${allLayers.length}個のカスタムレイヤーがあります`)

// GeoJSONデータを準備
const myRestrictedArea: GeoJSON.FeatureCollection = {
  type: 'FeatureCollection',
  features: [{
    type: 'Feature',
    geometry: {
      type: 'Polygon',
      coordinates: [[
        [139.7, 35.6],
        [139.71, 35.6],
        [139.71, 35.61],
        [139.7, 35.61],
        [139.7, 35.6]
      ]]
    },
    properties: {
      name: '工事現場周辺'
    }
  }]
}

// 新しいカスタムレイヤーを追加
const layer = CustomLayerService.add(
  {
    id: 'construction-zone',
    name: '工事現場周辺注意',
    type: 'restriction',
    category: 'hazard',
    color: '#FF6F00',
    opacity: 0.5,
    description: '2024年3月までの工事予定'
  },
  myRestrictedArea
)
console.log(`レイヤーを追加しました: ${layer.id}`)

// MapLibreで表示
map.addSource('construction', {
  type: 'geojson',
  data: myRestrictedArea
})

map.addLayer({
  id: 'construction-layer',
  type: 'fill',
  source: 'construction',
  paint: {
    'fill-color': '#FF6F00',
    'fill-opacity': 0.5
  }
})

// 後からメタデータを更新
CustomLayerService.update('construction-zone', {
  description: '2024年4月に工事完了予定'
})

// データをエクスポート
const jsonData = CustomLayerService.exportAll()
const blob = new Blob([JSON.stringify(jsonData)], { type: 'application/json' })
const url = URL.createObjectURL(blob)
// ダウンロードリンクを作成
```

### API詳細

#### add(metadata, geoJson)

**シグネチャ**
```typescript
static add(
  metadata: {
    id: string
    name: string
    type: 'restriction' | 'poi' | 'custom'
    category: string
    color: string
    opacity: number
    description?: string
  },
  geoJson: GeoJSON.FeatureCollection
): CustomLayer
```

**説明**  
新しいカスタムレイヤーを作成してLocalStorageに保存します。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>名前</th>
      <th>説明</th>
      <th>例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>レイヤーの一意識別子</td>
      <td>'my-poi', 'restricted-area-01'</td>
    </tr>
    <tr>
      <td>name</td>
      <td>表示用レイヤー名</td>
      <td>'着陸候補地点', '工事現場周辺'</td>
    </tr>
    <tr>
      <td>type</td>
      <td>レイヤー種類</td>
      <td>'restriction' | 'poi' | 'custom'</td>
    </tr>
    <tr>
      <td>color</td>
      <td>MapLibre表示色（16進数）</td>
      <td>'#FF5722'</td>
    </tr>
    <tr>
      <td>opacity</td>
      <td>透明度（0-1）</td>
      <td>0.5</td>
    </tr>
  </tbody>
</table>

**戻り値**
- `CustomLayer` - 作成されたレイヤー（createdAt, updatedAtは自動設定）

**計算量**  
O(1) - LocalStorage書き込み

**例外**
```typescript
try {
  const layer = CustomLayerService.add(metadata, geoJson)
} catch (error) {
  if (error.message.includes('storage')) {
    console.error('LocalStorageが満杯です')
  }
}
```

**例**
```typescript
const poiLayer = CustomLayerService.add(
  {
    id: 'heliports',
    name: '公開ヘリポート',
    type: 'poi',
    category: 'landing',
    color: '#2196F3',
    opacity: 0.8,
    description: 'ASNARO登録済みヘリポート'
  },
  heliportGeoJSON
)
```

---

#### getAll()

**シグネチャ**
```typescript
static getAll(): CustomLayer[]
```

**説明**  
全てのカスタムレイヤーを取得します。

**戻り値**
- `CustomLayer[]` - 保存されているレイヤーの配列

**計算量**  
O(1) - キャッシュ取得

**例**
```typescript
const layers = CustomLayerService.getAll()
layers.forEach(layer => {
  console.log(`${layer.name}: ${layer.data.features.length}個のフィーチャー`)
})
```

---

#### getById(id: string)

**シグネチャ**
```typescript
static getById(id: string): CustomLayer | null
```

**説明**  
IDでカスタムレイヤーを検索します。

**戻り値**
- `CustomLayer` - マッチしたレイヤー
- `null` - 見つからない場合

**例**
```typescript
const layer = CustomLayerService.getById('my-poi')
if (layer) {
  console.log(`${layer.name}には${layer.data.features.length}個のポイント`)
}
```

---

#### update(id: string, updates)

**シグネチャ**
```typescript
static update(
  id: string,
  updates: Partial<Omit<CustomLayer, 'id' | 'data'>>
): CustomLayer | null
```

**説明**  
既存のレイヤーメタデータを更新します（GeoJSONデータは更新されません）。

**パラメータ**
<table>
  <thead>
    <tr>
      <th>フィールド</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>レイヤー名の更新</td>
    </tr>
    <tr>
      <td>color</td>
      <td>表示色の変更</td>
    </tr>
    <tr>
      <td>opacity</td>
      <td>透明度の変更</td>
    </tr>
    <tr>
      <td>description</td>
      <td>説明テキストの更新</td>
    </tr>
  </tbody>
</table>

**戻り値**
- `CustomLayer` - 更新されたレイヤー
- `null` - レイヤーが見つからない場合

**例**
```typescript
CustomLayerService.update('my-poi', {
  color: '#4CAF50',
  opacity: 0.7,
  description: '2024年3月更新'
})
```

---

#### remove(id: string)

**シグネチャ**
```typescript
static remove(id: string): boolean
```

**説明**  
カスタムレイヤーを削除します。

**戻り値**
- `true` - 削除成功
- `false` - レイヤーが見つからない場合

**例**
```typescript
if (CustomLayerService.remove('outdated-layer')) {
  console.log('レイヤーを削除しました')
}
```

---

#### exportAll()

**シグネチャ**
```typescript
static exportAll(): CustomLayerExport[]
```

**説明**  
全てのカスタムレイヤーをJSON形式でエクスポートします。

**戻り値**
```typescript
{
  version: string
  exportedAt: number
  layers: CustomLayer[]
}
```

**用途**
- バックアップ作成
- チーム間でのデータ共有
- 別デバイスへの転送

**例**
```typescript
const exportData = CustomLayerService.exportAll()
const blob = new Blob([JSON.stringify(exportData)], { type: 'application/json' })
const url = URL.createObjectURL(blob)
const a = document.createElement('a')
a.href = url
a.download = `layers-${Date.now()}.json`
a.click()
```

---

#### import(jsonString: string)

**シグネチャ**
```typescript
static import(jsonString: string): {
  success: boolean
  count: number
  errors?: string[]
}
```

**説明**  
JSON形式のレイヤーデータをインポートします。

**戻り値**
```typescript
{
  success: boolean    // インポート成功の有無
  count: number       // インポートされたレイヤー数
  errors?: string[]   // エラーメッセージ配列
}
```

**例**
```typescript
const fileInput = document.querySelector('input[type=file]') as HTMLInputElement
fileInput?.addEventListener('change', async (e) => {
  const file = (e.target as HTMLInputElement).files?.[0]
  if (!file) return
  
  const text = await file.text()
  const result = CustomLayerService.import(text)
  
  if (result.success) {
    console.log(`${result.count}個のレイヤーをインポートしました`)
  } else {
    console.error('インポート失敗:', result.errors)
  }
})
```

---

#### exportAsGeoJSON(id: string)

**シグネチャ**
```typescript
static exportAsGeoJSON(id: string): GeoJSON.FeatureCollection | null
```

**説明**  
特定のレイヤーのみGeoJSON形式でエクスポートします。

**戻り値**
- `GeoJSON.FeatureCollection` - GeoJSONデータ
- `null` - レイヤーが見つからない場合

**用途**
- 他のGISソフトウェア（QGIS、ArcGISなど）で編集
- WEB APIサーバーへアップロード

**例**
```typescript
const geoJson = CustomLayerService.exportAsGeoJSON('my-poi')
if (geoJson) {
  fetch('/api/upload-geojson', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(geoJson)
  })
}
```

---

### ベストプラクティス

#### 1. 定期的なバックアップ

```typescript
function setupAutoBackup(intervalMinutes: number = 60) {
  setInterval(() => {
    const backup = CustomLayerService.exportAll()
    const key = `backup-${Date.now()}`
    localStorage.setItem(key, JSON.stringify(backup))
    
    // 古いバックアップを削除（最新10個まで保持）
    const allBackups = Object.keys(localStorage)
      .filter(k => k.startsWith('backup-'))
      .sort()
      .reverse()
    
    allBackups.slice(10).forEach(key => localStorage.removeItem(key))
  }, intervalMinutes * 60 * 1000)
}
```

#### 2. バージョン管理

```typescript
interface VersionedLayer {
  id: string
  versions: Array<{
    version: number
    data: CustomLayer
    changedAt: number
    changeDescription: string
  }>
}

function updateLayerWithVersion(id: string, updates: any, description: string) {
  const layer = CustomLayerService.getById(id)
  if (!layer) return
  
  const versionKey = `${id}-versions`
  const versions = JSON.parse(localStorage.getItem(versionKey) || '[]')
  
  versions.push({
    version: versions.length + 1,
    data: { ...layer, ...updates },
    changedAt: Date.now(),
    changeDescription: description
  })
  
  localStorage.setItem(versionKey, JSON.stringify(versions))
  CustomLayerService.update(id, updates)
}
```

#### 3. StorageQuota管理

```typescript
async function checkStorageUsage(): Promise<{
  used: number
  quota: number
  percentUsed: number
}> {
  if (!navigator.storage?.estimate) {
    return { used: 0, quota: 0, percentUsed: 0 }
  }
  
  const estimate = await navigator.storage.estimate()
  return {
    used: estimate.usage || 0,
    quota: estimate.quota || 0,
    percentUsed: ((estimate.usage || 0) / (estimate.quota || 1)) * 100
  }
}

// 使用
const usage = await checkStorageUsage()
if (usage.percentUsed > 80) {
  console.warn(`ストレージが${usage.percentUsed.toFixed(1)}%満杯です`)
}
```

### 実践例：複合飛行計画システム

```typescript
interface ComprehensiveFlightPlan {
  id: string
  name: string
  area: GeoJSON.FeatureCollection
  restrictions: CustomLayer[]
  poi: CustomLayer[]
  route: GeoJSON.FeatureCollection
  weather?: WeatherConditions
  approved: boolean
}

async function createComprehensiveFlightPlan(
  name: string,
  areaGeoJson: GeoJSON.FeatureCollection
): Promise<ComprehensiveFlightPlan> {
  // 飛行エリア
  const planLayerId = `plan-${Date.now()}`
  const planLayer = CustomLayerService.add(
    {
      id: planLayerId,
      name,
      type: 'custom',
      category: 'flight-plan',
      color: '#2196F3',
      opacity: 0.3,
      description: `飛行計画エリア: ${name}`
    },
    areaGeoJson
  )
  
  // 制限区域を重ねてチェック
  const allLayers = CustomLayerService.getAll()
  const restrictions = allLayers.filter(l => l.type === 'restriction')
  const poi = allLayers.filter(l => l.type === 'poi')
  
  // 飛行経路を生成
  const routeGeoJson = generateFlightRoute(areaGeoJson)
  
  return {
    id: planLayerId,
    name,
    area: areaGeoJson,
    restrictions,
    poi,
    route: routeGeoJson,
    approved: restrictions.length === 0
  }
}
```

### レイヤーデータ構造

```typescript
interface CustomLayer {
  id: string
  name: string
  type: 'restriction' | 'poi' | 'custom'
  category: string
  color: string
  opacity: number
  data: GeoJSON.FeatureCollection
  createdAt: number
  updatedAt: number
  description?: string
}

interface GeoJSON.FeatureCollection {
  type: 'FeatureCollection'
  features: Array<{
    type: 'Feature'
    geometry: Geometry
    properties: Record<string, any>
  }>
}
```
