{/* AdvancedImplementationExamples.mdx */}
import { Meta } from '@storybook/blocks'

<Meta title="Learning/Advanced Implementation Examples" />

# Advanced Implementation Examples

Real-world examples combining advanced React, TypeScript, and GSI patterns.

---

## 1. Flight Path Planner with State Management

A complete example combining `useReducer`, `useCallback`, `useMemo`, and GSI integration.

### State Definition

```typescript
import { useCallback, useMemo, useReducer, useRef, useEffect } from 'react'
import { GsiTileCache } from './gsiTileCache'
import { getVisibleTileXYZs, classifyKokuareaSurface } from './kokuarea'

// Type definitions
type FlightPlanState = {
  waypoints: [number, number][]
  restrictions: GeoJSON.Feature[]
  safetyBuffer: number // meters
  isValid: boolean
  errors: string[]
}

type FlightPlanAction =
  | { type: 'ADD_WAYPOINT'; coord: [number, number] }
  | { type: 'REMOVE_WAYPOINT'; index: number }
  | { type: 'LOAD_RESTRICTIONS'; features: GeoJSON.Feature[] }
  | { type: 'SET_SAFETY_BUFFER'; distance: number }
  | { type: 'VALIDATE' }
  | { type: 'RESET' }
```

### Reducer Implementation

```typescript
function flightPlanReducer(state: FlightPlanState, action: FlightPlanAction): FlightPlanState {
  switch (action.type) {
    case 'ADD_WAYPOINT':
      return {
        ...state,
        waypoints: [...state.waypoints, action.coord],
        isValid: false // Need revalidation
      }
    
    case 'REMOVE_WAYPOINT':
      return {
        ...state,
        waypoints: state.waypoints.filter((_, i) => i !== action.index),
        isValid: false
      }
    
    case 'LOAD_RESTRICTIONS':
      return {
        ...state,
        restrictions: action.features
      }
    
    case 'SET_SAFETY_BUFFER':
      return {
        ...state,
        safetyBuffer: action.distance,
        isValid: false
      }
    
    case 'VALIDATE': {
      const errors: string[] = []
      
      // Validate waypoint count
      if (state.waypoints.length < 2) {
        errors.push('At least 2 waypoints required')
      }
      
      // Validate waypoint spacing
      for (let i = 0; i < state.waypoints.length - 1; i++) {
        const [lon1, lat1] = state.waypoints[i]
        const [lon2, lat2] = state.waypoints[i + 1]
        const distance = haversineDistance([lon1, lat1], [lon2, lat2])
        
        if (distance < 10) { // 10m minimum
          errors.push(`Waypoints ${i} and ${i + 1} too close (${distance.toFixed(1)}m)`)
        }
      }
      
      // Validate against restriction zones
      for (let i = 0; i < state.waypoints.length; i++) {
        const waypoint = state.waypoints[i]
        for (const restriction of state.restrictions) {
          if (pointInPolygon(waypoint, restriction.geometry)) {
            const name = restriction.properties?.name || 'Unknown'
            errors.push(`Waypoint ${i} in restricted area: ${name}`)
          }
        }
      }
      
      return {
        ...state,
        isValid: errors.length === 0,
        errors
      }
    }
    
    case 'RESET':
      return {
        waypoints: [],
        restrictions: [],
        safetyBuffer: 30,
        isValid: false,
        errors: []
      }
    
    default:
      return state
  }
}

// Helper functions
function haversineDistance(
  [lon1, lat1]: [number, number],
  [lon2, lat2]: [number, number]
): number {
  const R = 6371000 // Earth radius in meters
  const dLat = ((lat2 - lat1) * Math.PI) / 180
  const dLon = ((lon2 - lon1) * Math.PI) / 180
  const a = Math.sin(dLat / 2) ** 2 +
    Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) ** 2
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
  return R * c
}

function pointInPolygon(point: [number, number], geometry: GeoJSON.Geometry): boolean {
  if (geometry.type !== 'Polygon') return false
  
  const [x, y] = point
  const polygon = geometry.coordinates[0]
  let isInside = false
  
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [xi, yi] = polygon[i]
    const [xj, yj] = polygon[j]
    
    const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi)
    if (intersect) isInside = !isInside
  }
  
  return isInside
}
```

### Component Implementation

```typescript
const FlightPlanner = () => {
  const mapRef = useRef<maplibregl.Map>(null)
  const tileCache = useMemo(() => new GsiTileCache(), [])
  
  const [state, dispatch] = useReducer(flightPlanReducer, {
    waypoints: [],
    restrictions: [],
    safetyBuffer: 30,
    isValid: false,
    errors: []
  })
  
  // Load Kokuarea tiles when map moves
  const loadRestrictionsFromKokuarea = useCallback(async () => {
    if (!mapRef.current) return
    
    const bounds = mapRef.current.getBounds()
    const zoom = mapRef.current.getZoom()
    
    if (zoom < 8) {
      dispatch({ type: 'LOAD_RESTRICTIONS', features: [] })
      return
    }
    
    const tiles = getVisibleTileXYZs(bounds, Math.floor(zoom))
    const features: GeoJSON.Feature[] = []
    
    for (const tile of tiles) {
      const url = `https://maps.gsi.go.jp/xyz/kokuarea/${tile.z}/${tile.x}/${tile.y}.geojson`
      
      try {
        const response = await fetch(url)
        if (!response.ok) throw new Error(`HTTP ${response.status}`)
        
        const geojson = await response.json()
        
        geojson.features.forEach((feature: GeoJSON.Feature) => {
          const { kind } = classifyKokuareaSurface(feature.properties || {})
          feature.properties = { ...feature.properties, __kind: kind }
          features.push(feature)
        })
      } catch (error) {
        console.warn(`Failed to load kokuarea tile ${tile.z}/${tile.x}/${tile.y}:`, error)
      }
    }
    
    dispatch({ type: 'LOAD_RESTRICTIONS', features })
  }, [])
  
  // Validate whenever state changes
  useEffect(() => {
    dispatch({ type: 'VALIDATE' })
  }, [state.waypoints, state.restrictions, state.safetyBuffer])
  
  // Load restrictions on map move
  useEffect(() => {
    if (!mapRef.current) return
    
    const handleMapMove = () => {
      loadRestrictionsFromKokuarea()
    }
    
    mapRef.current.on('moveend', handleMapMove)
    return () => {
      mapRef.current?.off('moveend', handleMapMove)
    }
  }, [loadRestrictionsFromKokuarea])
  
  // Handle map clicks to add waypoints
  const handleMapClick = useCallback((e: maplibregl.MapMouseEvent) => {
    dispatch({ type: 'ADD_WAYPOINT', coord: [e.lngLat.lng, e.lngLat.lat] })
  }, [])
  
  const exportFlightPlan = useCallback(() => {
    if (!state.isValid) {
      alert('Flight plan is not valid: ' + state.errors.join('\n'))
      return
    }
    
    const plan = {
      waypoints: state.waypoints,
      safetyBuffer: state.safetyBuffer,
      timestamp: new Date().toISOString(),
      version: '1.0'
    }
    
    const json = JSON.stringify(plan, null, 2)
    const blob = new Blob([json], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `flight-plan-${Date.now()}.json`
    a.click()
    URL.revokeObjectURL(url)
  }, [state.isValid, state.waypoints, state.safetyBuffer, state.errors])
  
  return (
    <div className="flight-planner">
      <div className="map-container">
        <div 
          id="map" 
          ref={mapRef} 
          onClick={handleMapClick}
          style={{ width: '100%', height: '600px' }} 
        />
      </div>
      
      <div className="planner-panel">
        <h3>Flight Plan</h3>
        
        <section className="waypoints">
          <h4>Waypoints ({state.waypoints.length})</h4>
          <ul>
            {state.waypoints.map((wp, i) => (
              <li key={i}>
                {i + 1}. [{wp[0].toFixed(4)}, {wp[1].toFixed(4)}]
                <button onClick={() => dispatch({ type: 'REMOVE_WAYPOINT', index: i })}>
                  Remove
                </button>
              </li>
            ))}
          </ul>
        </section>
        
        <section className="safety-buffer">
          <label>
            Safety Buffer (m):
            <input
              type="number"
              value={state.safetyBuffer}
              onChange={(e) =>
                dispatch({ type: 'SET_SAFETY_BUFFER', distance: Number(e.target.value) })
              }
              min="0"
              max="500"
            />
          </label>
        </section>
        
        <section className="validation">
          {state.isValid ? (
            <p className="valid">Plan is valid</p>
          ) : (
            <ul className="errors">
              {state.errors.map((error, i) => (
                <li key={i}>{error}</li>
              ))}
            </ul>
          )}
        </section>
        
        <div className="actions">
          <button onClick={exportFlightPlan} disabled={!state.isValid}>
            Export Plan
          </button>
          <button onClick={() => dispatch({ type: 'RESET' })}>
            Clear All
          </button>
        </div>
      </div>
    </div>
  )
}
```

---

## 2. Custom Hook: useGSITiles

Reusable hook for loading GSI tiles with caching.

```typescript
import { useCallback, useEffect, useRef, useState } from 'react'
import { getVisibleTileXYZs } from './kokuarea'

type UseTilesOptions = {
  minZoom?: number
  maxTiles?: number
  onError?: (error: Error) => void
}

export function useGSITiles(
  bounds: maplibregl.LngLatBounds | null,
  zoom: number,
  tileTemplate: string,
  options: UseTilesOptions = {}
) {
  const { minZoom = 0, maxTiles = 100, onError } = options
  
  const [tiles, setTiles] = useState<GeoJSON.FeatureCollection>({
    type: 'FeatureCollection',
    features: []
  })
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  
  const cacheRef = useRef(new Map<string, GeoJSON.Feature[]>())
  const abortControllerRef = useRef<AbortController | null>(null)
  
  const loadTiles = useCallback(async () => {
    if (!bounds || zoom < minZoom) {
      setTiles({ type: 'FeatureCollection', features: [] })
      return
    }
    
    // Cancel previous request
    abortControllerRef.current?.abort()
    abortControllerRef.current = new AbortController()
    
    setLoading(true)
    setError(null)
    
    try {
      const visibleTiles = getVisibleTileXYZs(bounds, Math.floor(zoom)).slice(0, maxTiles)
      const allFeatures: GeoJSON.Feature[] = []
      
      for (const tile of visibleTiles) {
        // Check cache first
        const cacheKey = `${tile.z}/${tile.x}/${tile.y}`
        
        if (cacheRef.current.has(cacheKey)) {
          allFeatures.push(...cacheRef.current.get(cacheKey)!)
          continue
        }
        
        // Fetch from network
        const url = tileTemplate
          .replace('{z}', String(tile.z))
          .replace('{x}', String(tile.x))
          .replace('{y}', String(tile.y))
        
        try {
          const response = await fetch(url, {
            signal: abortControllerRef.current.signal
          })
          
          if (!response.ok) throw new Error(`HTTP ${response.status}`)
          const geojson = await response.json()
          
          cacheRef.current.set(cacheKey, geojson.features || [])
          allFeatures.push(...(geojson.features || []))
        } catch (err) {
          console.warn(`Failed to load tile ${cacheKey}:`, err)
        }
      }
      
      setTiles({ type: 'FeatureCollection', features: allFeatures })
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error')
      setError(error)
      onError?.(error)
    } finally {
      setLoading(false)
    }
  }, [bounds, zoom, tileTemplate, minZoom, maxTiles, onError])
  
  useEffect(() => {
    loadTiles()
  }, [loadTiles])
  
  return { tiles, loading, error }
}

// Usage example
const KokuareaLayer = ({ bounds, zoom }) => {
  const { tiles, loading, error } = useGSITiles(
    bounds,
    zoom,
    'https://maps.gsi.go.jp/xyz/kokuarea/{z}/{x}/{y}.geojson',
    { minZoom: 8, maxTiles: 50 }
  )
  
  if (error) {
    return <div className="error">Failed to load airspace data</div>
  }
  
  if (loading) {
    return <div className="loading">Loading...</div>
  }
  
  return <GeoJsonLayer data={tiles} />
}
```

---

## 3. Type-Safe Layer Management

Using advanced TypeScript for layer configuration.

```typescript
// Type definitions
type LayerKind = 'raster' | 'vector' | 'geojson'

interface LayerConfig<T extends LayerKind = LayerKind> {
  id: string
  name: string
  kind: T
  opacity?: number
  minZoom?: number
  maxZoom?: number
}

interface RasterLayerConfig extends LayerConfig<'raster'> {
  tiles: string[]
  tileSize: number
}

interface VectorLayerConfig extends LayerConfig<'vector'> {
  data: GeoJSON.FeatureCollection
  styles: maplibregl.LayerSpecification[]
}

type AnyLayerConfig = RasterLayerConfig | VectorLayerConfig

// Type-safe layer manager
class LayerManager {
  private layers = new Map<string, AnyLayerConfig>()
  
  addLayer<T extends AnyLayerConfig>(config: T): void {
    this.layers.set(config.id, config)
  }
  
  getLayer<T extends LayerKind>(id: string, kind: T): Extract<AnyLayerConfig, { kind: T }> | null {
    const layer = this.layers.get(id)
    if (layer && layer.kind === kind) {
      return layer as Extract<AnyLayerConfig, { kind: T }>
    }
    return null
  }
  
  applyToMap(map: maplibregl.Map): void {
    for (const [_, config] of this.layers) {
      if (config.kind === 'raster') {
        const rasterConfig = config as RasterLayerConfig
        map.addSource(config.id, {
          type: 'raster',
          tiles: rasterConfig.tiles,
          tileSize: rasterConfig.tileSize
        })
      } else if (config.kind === 'vector') {
        const vectorConfig = config as VectorLayerConfig
        map.addSource(config.id, {
          type: 'geojson',
          data: vectorConfig.data
        })
      }
    }
  }
}

// Usage
const layerManager = new LayerManager()

layerManager.addLayer({
  id: 'gsi-base',
  name: '地理院標準',
  kind: 'raster',
  tiles: ['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png'],
  tileSize: 256,
  opacity: 1.0
})

layerManager.addLayer({
  id: 'kokuarea',
  name: '空港空域',
  kind: 'vector',
  data: { type: 'FeatureCollection', features: [] },
  styles: []
})

// Type-safe retrieval
const rasterLayer = layerManager.getLayer('gsi-base', 'raster') // Typed correctly
const vectorLayer = layerManager.getLayer('kokuarea', 'vector') // Typed correctly
```

---

## 4. Error Recovery Pattern

Implementing resilient data loading with fallbacks.

```typescript
interface CacheEntry<T> {
  data: T
  timestamp: number
  ttl: number // Time to live in ms
}

class ResilientTileLoader {
  private cache = new Map<string, CacheEntry<GeoJSON.FeatureCollection>>()
  private retryQueue: string[] = []
  
  async loadTilesWithFallback(
    url: string,
    fallbackData?: GeoJSON.FeatureCollection
  ): Promise<GeoJSON.FeatureCollection> {
    // Check cache
    const cached = this.getFromCache(url)
    if (cached) return cached
    
    // Try primary source
    try {
      const response = await fetch(url, { timeout: 5000 })
      if (response.ok) {
        const data = await response.json()
        this.setCache(url, data)
        return data
      }
    } catch (error) {
      console.warn(`Failed to fetch ${url}:`, error)
    }
    
    // Try fallback
    if (fallbackData) {
      return fallbackData
    }
    
    // Use empty data
    return { type: 'FeatureCollection', features: [] }
  }
  
  private getFromCache(key: string): GeoJSON.FeatureCollection | null {
    const entry = this.cache.get(key)
    if (!entry) return null
    
    const age = Date.now() - entry.timestamp
    if (age > entry.ttl) {
      this.cache.delete(key)
      return null
    }
    
    return entry.data
  }
  
  private setCache(
    key: string,
    data: GeoJSON.FeatureCollection,
    ttl: number = 5 * 60 * 1000 // 5 minutes
  ) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    })
  }
}

// Usage
const tileLoader = new ResilientTileLoader()
const fallbackKokuarea = { type: 'FeatureCollection', features: [] }

const kokuareaData = await tileLoader.loadTilesWithFallback(
  'https://maps.gsi.go.jp/xyz/kokuarea/10/584/403.geojson',
  fallbackKokuarea
)
```

---

## 5. Performance Monitoring

Tracking rendering performance and optimization opportunities.

```typescript
class PerformanceMonitor {
  private metrics = new Map<string, number[]>()
  
  markStart(label: string): void {
    performance.mark(`${label}-start`)
  }
  
  markEnd(label: string): number {
    performance.mark(`${label}-end`)
    performance.measure(label, `${label}-start`, `${label}-end`)
    
    const measure = performance.getEntriesByName(label)[0] as PerformanceMeasure
    const duration = measure.duration
    
    if (!this.metrics.has(label)) {
      this.metrics.set(label, [])
    }
    this.metrics.get(label)!.push(duration)
    
    return duration
  }
  
  getStats(label: string) {
    const values = this.metrics.get(label) || []
    if (values.length === 0) return null
    
    const avg = values.reduce((a, b) => a + b, 0) / values.length
    const max = Math.max(...values)
    const min = Math.min(...values)
    
    return { avg, max, min, count: values.length }
  }
  
  logStats(): void {
    for (const [label, values] of this.metrics) {
      const stats = this.getStats(label)
      console.log(`${label}: avg=${stats?.avg.toFixed(2)}ms, max=${stats?.max.toFixed(2)}ms`)
    }
  }
}

// Usage
const monitor = new PerformanceMonitor()

// In render function
monitor.markStart('kokuarea-render')
// ... render code
const duration = monitor.markEnd('kokuarea-render')

// Log performance
monitor.logStats()
```

---

## Best Practices Summary

1. **Use useReducer for complex state** - Centralizes state logic
2. **Memoize expensive computations** - useMemo for O(n²+) operations
3. **Type narrowing with type guards** - Prevents runtime type errors
4. **Custom hooks for reusability** - Encapsulate logic patterns
5. **Error boundaries and fallbacks** - Graceful degradation
6. **Performance monitoring** - Identify bottlenecks
7. **Caching strategies** - Reduce network load
8. **Validation before operations** - Catch errors early
