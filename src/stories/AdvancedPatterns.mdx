{/* AdvancedPatterns.mdx */}
import { Meta } from '@storybook/blocks'

<Meta title="Learning/Advanced Patterns & GSI" />

# Advanced Patterns and GSI Architecture

This guide covers advanced React/TypeScript patterns and provides a deep dive into the Geospatial Information Authority of Japan (GSI) architecture used in this project. It's designed for intermediate developers looking to understand sophisticated implementation techniques.

---

## Part 1: Advanced React Patterns

### 1.1 Custom Hooks for Reusability

Custom hooks allow you to extract component logic into reusable functions. This project uses custom hooks extensively for map state management, API calls, and UI coordination.

#### useCallback for Memoized Functions

The `useCallback` hook prevents function re-creation on every render, which is critical for performance when passing callbacks to memoized child components.

```typescript
import { useCallback, useState } from 'react'

// Bad: Function recreated on every render
const MapController = () => {
  const [layers, setLayers] = useState([])
  
  const handleAddLayer = (layer) => {
    setLayers([...layers, layer])
  }
  
  // handleAddLayer is a new function every render
  return <LayerManager onAddLayer={handleAddLayer} />
}

// Good: Function created once, dependencies tracked
const MapController = () => {
  const [layers, setLayers] = useState([])
  
  const handleAddLayer = useCallback((layer) => {
    setLayers(prev => [...prev, layer])
  }, []) // Empty deps = never recreates
  
  return <LayerManager onAddLayer={handleAddLayer} />
}
```

In this project's **DrawingTools.tsx** (line 754), `updateVertexLabels` uses `useCallback` to ensure the function identity remains stable across re-renders, preventing unnecessary canvas redraw operations.

#### useMemo for Expensive Computations

Memoize expensive calculations to avoid recalculation on every render.

```typescript
import { useMemo } from 'react'

// Calculate visible tiles based on map bounds
const VisibleTileRenderer = ({ bounds, zoomLevel }) => {
  const visibleTiles = useMemo(() => {
    // getVisibleTileXYZs is O(4^z) - expensive!
    return getVisibleTileXYZs(bounds, zoomLevel)
  }, [bounds, zoomLevel]) // Recalculate only when bounds/zoom changes
  
  return visibleTiles.map(tile => <Tile key={`${tile.z}-${tile.x}-${tile.y}`} {...tile} />)
}
```

The `kokuarea.ts` module provides `getVisibleTileXYZs()` which calculates O(4^z) tiles. Always memoize this result when used in React components.

#### useRef for Persistent Values

`useRef` stores a value that persists across renders without causing re-renders.

```typescript
import { useRef, useEffect } from 'react'

// MapLibre instance should be stored in a ref
const MapContainer = () => {
  const mapRef = useRef(null)
  
  useEffect(() => {
    if (!mapRef.current) {
      mapRef.current = new maplibregl.Map({
        container: 'map',
        style: 'https://...',
        center: [137.0, 36.5],
        zoom: 5
      })
    }
    
    return () => {
      mapRef.current.remove()
    }
  }, [])
  
  return <div id="map" style={{ width: '100%', height: '100%' }} />
}
```

### 1.2 useReducer for Complex State

When state updates depend on previous state or you have multiple related state variables, `useReducer` provides more control than `useState`.

```typescript
import { useReducer } from 'react'

type DrawingState = {
  features: Feature[]
  selectedFeatures: Set<string>
  mode: 'draw' | 'select' | 'edit'
  isDirty: boolean
}

type DrawingAction =
  | { type: 'ADD_FEATURE'; feature: Feature }
  | { type: 'DELETE_FEATURE'; featureId: string }
  | { type: 'SELECT_FEATURE'; featureId: string; multiSelect: boolean }
  | { type: 'CHANGE_MODE'; mode: DrawingState['mode'] }
  | { type: 'RESET' }

function drawingReducer(state: DrawingState, action: DrawingAction): DrawingState {
  switch (action.type) {
    case 'ADD_FEATURE':
      return {
        ...state,
        features: [...state.features, action.feature],
        isDirty: true
      }
    
    case 'DELETE_FEATURE':
      return {
        ...state,
        features: state.features.filter(f => f.id !== action.featureId),
        selectedFeatures: new Set(
          [...state.selectedFeatures].filter(id => id !== action.featureId)
        ),
        isDirty: true
      }
    
    case 'SELECT_FEATURE':
      const newSelected = new Set(state.selectedFeatures)
      if (action.multiSelect) {
        if (newSelected.has(action.featureId)) {
          newSelected.delete(action.featureId)
        } else {
          newSelected.add(action.featureId)
        }
      } else {
        newSelected.clear()
        newSelected.add(action.featureId)
      }
      return { ...state, selectedFeatures: newSelected }
    
    case 'CHANGE_MODE':
      return { ...state, mode: action.mode }
    
    case 'RESET':
      return {
        features: [],
        selectedFeatures: new Set(),
        mode: 'draw',
        isDirty: false
      }
    
    default:
      return state
  }
}

// Usage
const DrawingComponent = () => {
  const [state, dispatch] = useReducer(drawingReducer, {
    features: [],
    selectedFeatures: new Set(),
    mode: 'draw',
    isDirty: false
  })
  
  const handleAddFeature = (feature: Feature) => {
    dispatch({ type: 'ADD_FEATURE', feature })
  }
  
  const handleDelete = (featureId: string) => {
    dispatch({ type: 'DELETE_FEATURE', featureId })
  }
  
  return (
    <div>
      {/* UI that uses state and dispatch */}
    </div>
  )
}
```

### 1.3 React.memo for Component Optimization

`React.memo` prevents re-renders when props haven't changed.

```typescript
import { memo } from 'react'

// Without memo: re-renders when parent renders, even if props unchanged
const TileOverlay = (props) => {
  return <div className="tile">{props.id}</div>
}

// With memo: only re-renders if tile props change
const TileMemo = memo(function TileOverlay(props: TileProps) {
  return <div className="tile">{props.id}</div>
})

// In parent component
const MapTileGrid = () => {
  const tiles = useMemo(() => getTiles(), [])
  
  return tiles.map(tile => 
    <TileMemo key={tile.key} {...tile} /> // Only re-renders if tile object changes
  )
}
```

### 1.4 Error Boundaries for Graceful Error Handling

Error boundaries catch rendering errors and display a fallback UI.

```typescript
import { Component, ReactNode } from 'react'

interface ErrorBoundaryProps {
  children: ReactNode
  fallback?: ReactNode
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false, error: null }
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }
  
  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught by boundary:', error, errorInfo)
    // Log to error reporting service
  }
  
  render() {
    if (this.state.hasError) {
      return (
        this.props.fallback || (
          <div className="error-message">
            <h2>Something went wrong</h2>
            <p>{this.state.error?.message}</p>
          </div>
        )
      )
    }
    
    return this.props.children
  }
}

// Usage
<ErrorBoundary fallback={<MapLoadingError />}>
  <MapComponent />
</ErrorBoundary>
```

### 1.5 Context API for Cross-Component State

The Context API avoids prop drilling for widely-used state.

```typescript
import { createContext, useContext, ReactNode, useCallback } from 'react'

// Create context for map state
type MapContextType = {
  center: [number, number]
  zoom: number
  baseMap: BaseMapKey
  setCenter: (center: [number, number]) => void
  setZoom: (zoom: number) => void
  setBaseMap: (baseMap: BaseMapKey) => void
}

const MapContext = createContext<MapContextType | undefined>(undefined)

// Provider component
export const MapProvider = ({ children }: { children: ReactNode }) => {
  const [center, setCenter] = useState<[number, number]>([137.0, 36.5])
  const [zoom, setZoom] = useState(5)
  const [baseMap, setBaseMap] = useState<BaseMapKey>('osm')
  
  const value = useMemo(() => ({
    center,
    zoom,
    baseMap,
    setCenter,
    setZoom,
    setBaseMap
  }), [center, zoom, baseMap])
  
  return (
    <MapContext.Provider value={value}>
      {children}
    </MapContext.Provider>
  )
}

// Custom hook to use context
export const useMapContext = () => {
  const context = useContext(MapContext)
  if (!context) {
    throw new Error('useMapContext must be used within MapProvider')
  }
  return context
}

// Usage in components
const ZoomControl = () => {
  const { zoom, setZoom } = useMapContext()
  
  return (
    <div>
      <button onClick={() => setZoom(zoom + 1)}>Zoom In</button>
      <button onClick={() => setZoom(zoom - 1)}>Zoom Out</button>
    </div>
  )
}
```

---

## Part 2: Advanced TypeScript Patterns

### 2.1 Conditional Types

Conditional types select types based on conditions.

```typescript
// Type that extracts Promise return type
type Awaited<T> = T extends Promise<infer U> ? U : T

const fetchAirports: Promise<Airport[]> = // ...
type AirportArray = Awaited<typeof fetchAirports> // Airport[]

// Type-safe API response handler
type ApiResponse<T, E = Error> = { success: true; data: T } | { success: false; error: E }

function handleResponse<T>(response: ApiResponse<T>) {
  if (response.success) {
    // TypeScript knows response.data exists here
    console.log(response.data)
  } else {
    // TypeScript knows response.error exists here
    console.error(response.error)
  }
}
```

### 2.2 Mapped Types

Mapped types transform existing types.

```typescript
// Create readonly version of an object
type Readonly<T> = {
  readonly [K in keyof T]: T[K]
}

type MutableBaseMap = {
  name: string
  style: string | StyleSpecification
}

type ReadonlyBaseMap = Readonly<MutableBaseMap>
// Result: { readonly name: string; readonly style: string | StyleSpecification }

// Create "getters" for each property
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
}

type BaseMapGetters = Getters<BaseMap>
// Result: { getStyle: () => string | StyleSpecification; getName: () => string }
```

### 2.3 Type Guards and Type Predicates

Type predicates narrow types within conditional blocks.

```typescript
// Type predicate function
function isGeoOverlay(overlay: Overlay): overlay is GeoOverlay {
  return 'tiles' in overlay || 'geojson' in overlay
}

function isWeatherOverlay(overlay: Overlay): overlay is WeatherOverlay {
  return 'dynamic' in overlay && overlay.dynamic === true
}

// Usage
function processOverlay(overlay: Overlay) {
  if (isGeoOverlay(overlay)) {
    // TypeScript knows this is GeoOverlay
    loadTiles(overlay.tiles)
  } else if (isWeatherOverlay(overlay)) {
    // TypeScript knows this is WeatherOverlay
    startWeatherUpdates(overlay.updateInterval)
  }
}

// Exhaustiveness checking
function handleOverlay(overlay: GeoOverlay | WeatherOverlay): string {
  if (isGeoOverlay(overlay)) return 'geo'
  if (isWeatherOverlay(overlay)) return 'weather'
  
  const _exhaustive: never = overlay
  return _exhaustive
}
```

### 2.4 Generics with Constraints

Generic constraints ensure type parameters meet specific requirements.

```typescript
// Generic constraint: T must have these properties
interface GeoJsonFeature {
  type: 'Feature'
  properties: Record<string, unknown>
  geometry: Geometry
}

function processFeature<T extends GeoJsonFeature>(feature: T): T {
  if (!feature.properties) {
    throw new Error('Feature must have properties')
  }
  return feature
}

// Generic constraint for array items
function getFirstElement<T extends readonly unknown[]>(arr: T): T[0] {
  return arr[0]
}

// Generic factory function
interface Service {
  initialize(): Promise<void>
  destroy(): void
}

function createService<T extends Service>(ServiceClass: new () => T): T {
  return new ServiceClass()
}

const rainViewerService = createService(RainViewerService)
```

### 2.5 Utility Types for Common Transformations

```typescript
// Partial<T>: All properties become optional
type PartialBaseMap = Partial<BaseMap>
// { style?: ..., name?: ... }

// Required<T>: All properties become required
type RequiredBaseMap = Required<Partial<BaseMap>>

// Omit<T, K>: Exclude specified properties
type BaseMapWithoutStyle = Omit<BaseMap, 'style'>

// Pick<T, K>: Include only specified properties
type BaseMapNameOnly = Pick<BaseMap, 'name'>

// Record<K, T>: Create object with specific keys
type BaseMapRecord = Record<BaseMapKey, BaseMap>

// ReturnType<T>: Extract return type from function
type FetchAirportsReturn = ReturnType<typeof fetchAirports>

// Parameters<T>: Extract parameter types from function
type FetchAirportsParams = Parameters<typeof fetchAirports>

// Exclude<T, U>: Remove types matching U from T
type NonErrorResponse = Exclude<ApiResponse<Airport>, { success: false }>
```

---

## Part 3: Deep Dive into GSI (Geospatial Information Authority of Japan) Architecture

### 3.1 What is GSI?

The **Geospatial Information Authority of Japan (国土地理院)** is Japan's official national mapping organization. GSI provides free, high-quality geospatial data through the **Cyberjapan platform** (CyberJapan Tiles) and the **Kokuarea service** for administrative boundary and airport airspace data.

Key aspects of GSI:
- **Official source**: Maintains Japan's national geographic data
- **Free access**: No API key required for basic tiles
- **High quality**: Data verified against field surveys
- **Attribution required**: All maps must include attribution to GSI

### 3.2 Tile Coordinate System (XYZ)

GSI uses the **XYZ tile addressing system**, a standard for web maps. This system divides the world into square tiles at different zoom levels.

#### How XYZ Coordinates Work

At **zoom level z**, the world is divided into `2^z` × `2^z` tiles:
- **z = 0**: 1 × 1 = 1 tile (whole world)
- **z = 1**: 2 × 2 = 4 tiles
- **z = 2**: 4 × 4 = 16 tiles
- **z = 10**: 1024 × 1024 = 1,048,576 tiles

Each tile has coordinates (x, y) where:
- **x** ranges from 0 to 2^z - 1 (longitude, west to east)
- **y** ranges from 0 to 2^z - 1 (latitude, north to south)

#### Conversion Formula

Converting geographic coordinates to tile coordinates:

```typescript
function lonLatToTile(lon: number, lat: number, z: number): { x: number; y: number } {
  const n = Math.pow(2, z)
  
  // X: Convert longitude to tile X coordinate
  const x = Math.floor(((lon + 180) / 360) * n)
  
  // Y: Convert latitude using Web Mercator projection
  const latRad = (lat * Math.PI) / 180
  const y = Math.floor(
    ((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2) * n
  )
  
  return { x, y }
}

// Example: Tokyo at zoom 10
const tile = lonLatToTile(139.7, 35.67, 10)
// Result: { x: 584, y: 403 }
```

The reverse conversion:

```typescript
function tileToLonLat(x: number, y: number, z: number): [number, number] {
  const n = Math.pow(2, z)
  
  // Longitude: Simple inverse of x calculation
  const lon = (x / n) * 360 - 180
  
  // Latitude: Inverse of Web Mercator projection
  const latRad = Math.atan(Math.sinh(Math.PI * (1 - (y / n) * 2)))
  const lat = (latRad * 180) / Math.PI
  
  return [lon, lat]
}

// Example: Tile 584, 403 at zoom 10
const [lon, lat] = tileToLonLat(584, 403, 10)
// Result: [139.69..., 35.66...]
```

This project uses these conversions in `kokuarea.ts` (lines 72-87) for calculating visible tiles within map bounds:

```typescript
function toTileX(lon: number, z: number): number {
  const n = 2 ** z
  return Math.floor(((lon + 180) / 360) * n)
}

function toTileY(lat: number, z: number): number {
  const n = 2 ** z
  const latRad = (lat * Math.PI) / 180
  const y = (1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2
  return Math.floor(y * n)
}
```

### 3.3 Web Mercator Projection (EPSG:3857)

GSI tiles use the **Web Mercator projection** (EPSG:3857), which is the standard for web mapping.

#### Why Web Mercator?

Web Mercator provides:
1. **Seamless tile alignment**: Tiles fit together perfectly
2. **Square tiles**: Makes rendering efficient
3. **Zero distortion at equator**: Acceptable for most applications
4. **Conformal projection**: Preserves angles (good for navigation)

#### Web Mercator Mathematical Model

```typescript
const EARTH_RADIUS = 6378137 // meters

// Convert lat/lon to Web Mercator coordinates
function toMercator(lon: number, lat: number): { x: number; y: number } {
  const x = (lon * EARTH_RADIUS * Math.PI) / 180
  const latRad = (lat * Math.PI) / 180
  const y = EARTH_RADIUS * Math.log(Math.tan(Math.PI / 4 + latRad / 2))
  return { x, y }
}

// Convert Web Mercator coordinates back to lat/lon
function fromMercator(x: number, y: number): [number, number] {
  const lon = (x * 180) / (EARTH_RADIUS * Math.PI)
  const lat = (Math.atan(Math.sinh(y / EARTH_RADIUS)) * 180) / Math.PI
  return [lon, lat]
}
```

Important limitation: Web Mercator cannot represent areas beyond ±85.051129° latitude (Mercator singularity at poles). GSI tiles are cut off at this latitude.

### 3.4 GSI Tile Services

GSI provides multiple tile layers through Cyberjapan:

<table>
  <thead>
    <tr>
      <th>Service Name</th>
      <th>URL Path</th>
      <th>Type</th>
      <th>Use Case</th>
      <th>Format</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Standard Map (標準)</td>
      <td>std/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>General purpose mapping</td>
      <td>PNG</td>
    </tr>
    <tr>
      <td>Pale Map (淡色地図)</td>
      <td>pale/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Light background for overlays</td>
      <td>PNG</td>
    </tr>
    <tr>
      <td>Aerial Photo (航空写真)</td>
      <td>seamlessphoto/{z}/{x}/{y}.jpg</td>
      <td>Raster</td>
      <td>High-detail aerial imagery</td>
      <td>JPEG</td>
    </tr>
    <tr>
      <td>Hillshade (陰影起伏)</td>
      <td>hillshademap/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Terrain shading overlay</td>
      <td>PNG</td>
    </tr>
    <tr>
      <td>Colored Relief (色別標高)</td>
      <td>relief/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Elevation visualization</td>
      <td>PNG</td>
    </tr>
    <tr>
      <td>Slope Map (傾斜量図)</td>
      <td>slopemap/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Steep slope visualization</td>
      <td>PNG</td>
    </tr>
    <tr>
      <td>DID 2015 (人口集中地区)</td>
      <td>did2015/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Population density area</td>
      <td>PNG</td>
    </tr>
    <tr>
      <td>Kokuarea (国家基盤)</td>
      <td>kokuarea/{z}/{x}/{y}.geojson</td>
      <td>GeoJSON Vector Tiles</td>
      <td>Airport airspace boundaries</td>
      <td>GeoJSON</td>
    </tr>
    <tr>
      <td>Building Vectors (地物)</td>
      <td>experimental_bvmap/{z}/{x}/{y}.pbf</td>
      <td>Vector Protobuf</td>
      <td>Building footprints (experimental)</td>
      <td>PBF</td>
    </tr>
  </tbody>
</table>

#### URL Template Pattern

All GSI tiles follow this pattern:

```
https://cyberjapandata.gsi.go.jp/xyz/{service}/{z}/{x}/{y}.{format}
```

Where:
- `{service}`: Service identifier (std, pale, seamlessphoto, etc.)
- `{z}`: Zoom level (0-18 typically)
- `{x}`: Tile X coordinate
- `{y}`: Tile Y coordinate
- `{format}`: png, jpg, pbf, geojson

In this project (baseMaps.ts, line 23):

```typescript
tiles: ['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png']
```

MapLibre GL automatically fills in `{z}`, `{x}`, and `{y}` based on the current viewport.

### 3.5 Kokuarea Vector Tiles (Detailed Explanation)

The **Kokuarea service** (国家基盤) provides GeoJSON vector tiles containing airport airspace boundaries (進入表面, 転移表面, 水平表面, 円錐表面).

#### Kokuarea Data Structure

Each feature in a Kokuarea tile has properties like:

```json
{
  "type": "Feature",
  "properties": {
    "name": "成田国際空港-B'-進入表面",
    "description": "Approach surface for Narita International Airport",
    "airport_code": "NRT",
    "surface_type": "approach"
  },
  "geometry": {
    "type": "Polygon",
    "coordinates": [[[...], [...], ...]]
  }
}
```

This project's `kokuarea.ts` provides:

1. **`classifyKokuareaSurface()`**: Analyzes feature properties to categorize the surface type (approach, transitional, horizontal, conical) and assign styling

2. **`getVisibleTileXYZs()`**: Calculates which tiles are visible in the current map bounds at a given zoom level

3. **`fillKokuareaTileUrl()`**: Fills a tile URL template with specific coordinates

#### Performance Considerations for Kokuarea

Vector tiles are more CPU-intensive than raster tiles:

- **Loading**: Smaller file size than raster (typically 20-40KB per tile)
- **Parsing**: Must decode and parse GeoJSON at client (O(n) where n = features per tile)
- **Rendering**: MapLibre renders each feature according to style rules
- **Memory**: Entire GeoJSON must be in memory (can accumulate at high zoom levels)

Optimization strategy:

```typescript
// Only load Kokuarea tiles above zoom 8 to reduce load
const visibleTiles = useMemo(() => {
  if (zoomLevel < 8) return [] // Skip loading
  return getVisibleTileXYZs(mapBounds, zoomLevel)
}, [mapBounds, zoomLevel])
```

### 3.6 Attribution Requirements

GSI requires proper attribution. In this project (baseMaps.ts, line 8):

```typescript
const GSI_ATTRIBUTION = '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">国土地理院</a>'
```

Every MapLibre style that uses GSI tiles must include this attribution in the `attribution` property. MapLibre automatically displays this in the bottom-right corner.

### 3.7 Zoom Level Definitions and Coverage

GSI tiles are available at zoom levels 0-18:

<table>
  <thead>
    <tr>
      <th>Zoom Level</th>
      <th>Scale</th>
      <th>Use Case</th>
      <th>Tile Count at Level</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0-4</td>
      <td>World - Country</td>
      <td>Global overview</td>
      <td>1 - 256 tiles</td>
    </tr>
    <tr>
      <td>5-8</td>
      <td>Prefecture - City</td>
      <td>Regional view, flight planning</td>
      <td>1024 - 65536 tiles</td>
    </tr>
    <tr>
      <td>9-12</td>
      <td>District - Block</td>
      <td>Detailed flight paths, obstacle avoidance</td>
      <td>262144 - 16M tiles</td>
    </tr>
    <tr>
      <td>13-15</td>
      <td>Building - Detail</td>
      <td>Close-up inspection, precision operations</td>
      <td>8M - 256M tiles</td>
    </tr>
    <tr>
      <td>16-18</td>
      <td>Street - Property</td>
      <td>Maximum detail</td>
      <td>256M - 4B tiles</td>
    </tr>
  </tbody>
</table>

In this project, the default zoom is 5 (DEFAULT_ZOOM in baseMaps.ts, line 57), showing the entire Japan at prefecture level.

### 3.8 GSI Integration in MapLibre

MapLibre consumes GSI tiles through the style specification:

```typescript
const style: maplibregl.StyleSpecification = {
  version: 8,
  sources: {
    gsi: {
      type: 'raster',                    // Raster tiles (image tiles)
      tiles: ['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png'],
      tileSize: 256,                     // Standard web map tile size
      attribution: GSI_ATTRIBUTION        // Attribution link
    }
  },
  layers: [
    {
      id: 'gsi-layer',
      type: 'raster',
      source: 'gsi'
      // No style properties needed for raster layers
    }
  ]
}
```

For vector tiles (Kokuarea):

```typescript
const style: maplibregl.StyleSpecification = {
  sources: {
    kokuarea: {
      type: 'geojson',                   // GeoJSON source
      data: {
        type: 'FeatureCollection',
        features: [] // Populated dynamically
      }
    }
  },
  layers: [
    {
      id: 'kokuarea-approach',
      type: 'fill',
      source: 'kokuarea',
      filter: ['==', ['get', '__koku_kind'], 'approach'],
      paint: {
        'fill-color': '#4CAF50',
        'fill-opacity': 0.25
      }
    },
    {
      id: 'kokuarea-approach-outline',
      type: 'line',
      source: 'kokuarea',
      filter: ['==', ['get', '__koku_kind'], 'approach'],
      paint: {
        'line-color': '#2E7D32',
        'line-width': 1.2
      }
    }
  ]
}
```

---

## Part 4: Integration Patterns with This Project

### 4.1 BASE_MAPS Configuration Structure

The `BASE_MAPS` object in `baseMaps.ts` centralizes all available base map layers. Each entry provides:
- A user-facing name (Japanese)
- A complete MapLibre style specification or URL

```typescript
// Pattern: Raster tile layer (GSI Standard)
gsi: {
  name: '地理院',
  style: {
    version: 8,
    sources: {
      gsi: {
        type: 'raster',
        tiles: ['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png'],
        tileSize: 256,
        attribution: GSI_ATTRIBUTION
      }
    },
    layers: [{ id: 'gsi-layer', type: 'raster', source: 'gsi' }]
  }
}
```

To add a new base map layer:

1. Add entry to BASE_MAPS
2. Create style specification with proper sources and layers
3. Include attribution if using third-party data
4. Test at various zoom levels

```typescript
export const BASE_MAPS = {
  // Existing maps...
  
  // Add new layer for Noto earthquake monitoring
  noto_dem: {
    name: '能登DEM',
    style: {
      version: 8,
      sources: {
        dem: {
          type: 'raster',
          tiles: ['https://cyberjapandata.gsi.go.jp/xyz/dem/{z}/{x}/{y}.png'],
          tileSize: 256,
          attribution: GSI_ATTRIBUTION
        }
      },
      layers: [{ id: 'dem-layer', type: 'raster', source: 'dem' }]
    }
  }
}
```

### 4.2 Overlays Configuration with GSI Data

The `overlays.ts` file manages all optional overlay layers, many using GSI tile services:

```typescript
// Hillshade overlay (adds terrain texture)
{
  id: 'hillshade',
  name: '陰影起伏',
  tiles: ['https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png'],
  opacity: 0.4,
  category: 'geo'
}

// Custom: Using multiple GSI services together
const ELEVATION_LAYER_STACK = [
  {
    id: 'dem-colored',
    name: 'Color Relief with Hillshade',
    // Would require composite rendering
    description: 'GSI colored relief with hillshade overlay'
  }
]
```

### 4.3 Kokuarea Integration Pattern

Using Kokuarea vector tiles for airport airspace visualization:

```typescript
// app.tsx or map component
const handleKokuareaDisplay = useCallback(() => {
  const bounds = mapRef.current.getBounds()
  const zoom = mapRef.current.getZoom()
  
  // Only load above zoom 8
  if (zoom < 8) {
    clearKokuareaSource()
    return
  }
  
  // Calculate visible tiles
  const tiles = getVisibleTileXYZs(bounds, Math.floor(zoom))
  
  // Fetch and parse each tile's GeoJSON
  const features: GeoJsonFeature[] = []
  
  for (const tile of tiles) {
    const url = fillKokuareaTileUrl(
      'https://maps.gsi.go.jp/xyz/kokuarea/{z}/{x}/{y}.geojson',
      tile.z,
      tile.x,
      tile.y
    )
    
    try {
      const response = await fetch(url)
      const geojson = await response.json()
      
      // Classify each feature
      geojson.features.forEach(feature => {
        const classification = classifyKokuareaSurface(feature.properties)
        feature.properties.__koku_kind = classification.kind
        feature.properties.__koku_label = classification.label
        features.push(feature)
      })
    } catch (error) {
      console.warn(`Failed to load kokuarea tile ${tile.z}/${tile.x}/${tile.y}`, error)
    }
  }
  
  // Update source with aggregated features
  mapRef.current.getSource('kokuarea').setData({
    type: 'FeatureCollection',
    features
  })
}, [])

// Re-run on map movement
useEffect(() => {
  mapRef.current?.on('moveend', handleKokuareaDisplay)
  return () => mapRef.current?.off('moveend', handleKokuareaDisplay)
}, [handleKokuareaDisplay])
```

### 4.4 Custom Style Creation with GSI Layers

Creating advanced styling that combines multiple GSI data sources:

```typescript
function createAdvancedDroneFlightStyle(): maplibregl.StyleSpecification {
  return {
    version: 8,
    sources: {
      // Base map
      base: {
        type: 'raster',
        tiles: ['https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png'], // Light background
        tileSize: 256,
        attribution: GSI_ATTRIBUTION
      },
      // Overlay: Elevation data
      dem: {
        type: 'raster',
        tiles: ['https://cyberjapandata.gsi.go.jp/xyz/relief/{z}/{x}/{y}.png'],
        tileSize: 256
      },
      // Overlay: Buildings
      buildings: {
        type: 'raster',
        tiles: ['https://cyberjapandata.gsi.go.jp/xyz/experimental_bvmap/{z}/{x}/{y}.pbf'],
        tileSize: 256
      },
      // Custom: Kokuarea airspace
      kokuarea: {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      },
      // Custom: Restricted zones
      restricted: {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      }
    },
    layers: [
      // Base: GSI pale map
      { id: 'base', type: 'raster', source: 'base' },
      
      // Overlay: Elevation relief
      {
        id: 'elevation',
        type: 'raster',
        source: 'dem',
        paint: { 'raster-opacity': 0.3 }
      },
      
      // Overlay: Kokuarea boundaries
      {
        id: 'kokuarea-fill',
        type: 'fill',
        source: 'kokuarea',
        paint: {
          'fill-color': ['case',
            ['==', ['get', '__koku_kind'], 'approach'], '#4CAF50',
            ['==', ['get', '__koku_kind'], 'transitional'], '#FFC107',
            '#90EE90'
          ],
          'fill-opacity': 0.2
        }
      },
      {
        id: 'kokuarea-line',
        type: 'line',
        source: 'kokuarea',
        paint: {
          'line-color': ['case',
            ['==', ['get', '__koku_kind'], 'approach'], '#2E7D32',
            ['==', ['get', '__koku_kind'], 'transitional'], '#FF8F00',
            '#2E7D32'
          ],
          'line-width': 1.5
        }
      },
      
      // Overlay: Restricted zones
      {
        id: 'restricted-fill',
        type: 'fill',
        source: 'restricted',
        paint: {
          'fill-color': ['get', 'color'],
          'fill-opacity': 0.3
        }
      }
    ]
  }
}
```

### 4.5 Caching Strategies for GSI Tiles

GSI tiles are requested frequently. Implement caching to reduce bandwidth:

```typescript
class GsiTileCache {
  private cache = new Map<string, ArrayBuffer>()
  private maxSize = 100 // Cache max 100 tiles
  
  async fetch(url: string): Promise<ArrayBuffer> {
    // Check cache
    if (this.cache.has(url)) {
      return this.cache.get(url)!
    }
    
    // Fetch from network
    const response = await fetch(url)
    const buffer = await response.arrayBuffer()
    
    // Store in cache (FIFO if exceeds size)
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    
    this.cache.set(url, buffer)
    return buffer
  }
  
  clear() {
    this.cache.clear()
  }
}
```

---

## Part 5: Real-World Implementation Example

### Building a Flight Path Planner with GSI Integration

This example combines advanced patterns and GSI architecture:

```typescript
import { useCallback, useMemo, useReducer, useRef, useEffect } from 'react'
import { GsiTileCache } from './gsiTileCache'
import { getVisibleTileXYZs, classifyKokuareaSurface } from './kokuarea'

// State management with useReducer
type FlightPlanState = {
  waypoints: [number, number][]
  restrictions: GeoJSON.Feature[]
  safetyBuffer: number // meters
  isValid: boolean
  errors: string[]
}

type FlightPlanAction =
  | { type: 'ADD_WAYPOINT'; coord: [number, number] }
  | { type: 'LOAD_RESTRICTIONS'; features: GeoJSON.Feature[] }
  | { type: 'SET_SAFETY_BUFFER'; distance: number }
  | { type: 'VALIDATE' }
  | { type: 'RESET' }

function flightPlanReducer(state: FlightPlanState, action: FlightPlanAction): FlightPlanState {
  switch (action.type) {
    case 'ADD_WAYPOINT':
      return {
        ...state,
        waypoints: [...state.waypoints, action.coord],
        isValid: false // Need revalidation
      }
    
    case 'LOAD_RESTRICTIONS':
      return {
        ...state,
        restrictions: action.features
      }
    
    case 'SET_SAFETY_BUFFER':
      return {
        ...state,
        safetyBuffer: action.distance,
        isValid: false
      }
    
    case 'VALIDATE': {
      const errors: string[] = []
      
      // Check waypoint count
      if (state.waypoints.length < 2) {
        errors.push('At least 2 waypoints required')
      }
      
      // Check for restriction violations
      for (const waypoint of state.waypoints) {
        for (const restriction of state.restrictions) {
          if (pointInPolygon(waypoint, restriction.geometry)) {
            errors.push(`Waypoint ${waypoint} in restricted area`)
          }
        }
      }
      
      return {
        ...state,
        isValid: errors.length === 0,
        errors
      }
    }
    
    case 'RESET':
      return {
        waypoints: [],
        restrictions: [],
        safetyBuffer: 30,
        isValid: false,
        errors: []
      }
    
    default:
      return state
  }
}

// Component
const FlightPlannerWithGSI = () => {
  const mapRef = useRef<maplibregl.Map>(null)
  const tileCache = useMemo(() => new GsiTileCache(), [])
  const [state, dispatch] = useReducer(flightPlanReducer, {
    waypoints: [],
    restrictions: [],
    safetyBuffer: 30,
    isValid: false,
    errors: []
  })
  
  // Load Kokuarea restrictions (memoized)
  const loadRestrictionsFromKokuarea = useCallback(async () => {
    const bounds = mapRef.current!.getBounds()
    const zoom = mapRef.current!.getZoom()
    
    if (zoom < 8) return
    
    const tiles = getVisibleTileXYZs(bounds, Math.floor(zoom))
    const features: GeoJSON.Feature[] = []
    
    for (const tile of tiles) {
      const url = `https://maps.gsi.go.jp/xyz/kokuarea/${tile.z}/${tile.x}/${tile.y}.geojson`
      
      try {
        const buffer = await tileCache.fetch(url)
        const text = new TextDecoder().decode(buffer)
        const geojson = JSON.parse(text)
        
        geojson.features.forEach(feature => {
          const { kind } = classifyKokuareaSurface(feature.properties)
          feature.properties.__kind = kind
          features.push(feature)
        })
      } catch (error) {
        console.warn(`Failed to load tile ${tile.z}/${tile.x}/${tile.y}`, error)
      }
    }
    
    dispatch({ type: 'LOAD_RESTRICTIONS', features })
  }, [tileCache])
  
  // Validate plan whenever state changes
  useEffect(() => {
    dispatch({ type: 'VALIDATE' })
  }, [state.waypoints, state.restrictions, state.safetyBuffer])
  
  const addWaypoint = useCallback((coord: [number, number]) => {
    dispatch({ type: 'ADD_WAYPOINT', coord })
  }, [])
  
  const setSafetyBuffer = useCallback((distance: number) => {
    dispatch({ type: 'SET_SAFETY_BUFFER', distance })
  }, [])
  
  const exportFlightPlan = useCallback(() => {
    if (!state.isValid) {
      alert('Flight plan is not valid: ' + state.errors.join(', '))
      return
    }
    
    const plan = {
      waypoints: state.waypoints,
      safetyBuffer: state.safetyBuffer,
      timestamp: new Date().toISOString()
    }
    
    const json = JSON.stringify(plan, null, 2)
    const blob = new Blob([json], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `flight-plan-${Date.now()}.json`
    a.click()
  }, [state.isValid, state.waypoints, state.safetyBuffer, state.errors])
  
  return (
    <div className="flight-planner">
      <div className="map-container">
        <div id="map" ref={mapRef} style={{ width: '100%', height: '600px' }} />
      </div>
      
      <div className="planner-controls">
        <h3>Flight Plan</h3>
        <p>Waypoints: {state.waypoints.length}</p>
        <p>Safety Buffer: {state.safetyBuffer}m</p>
        
        {state.errors.length > 0 && (
          <div className="errors">
            {state.errors.map((error, idx) => <p key={idx}>{error}</p>)}
          </div>
        )}
        
        <button onClick={loadRestrictionsFromKokuarea}>Load Airspace Restrictions</button>
        <button onClick={exportFlightPlan} disabled={!state.isValid}>Export Plan</button>
        <button onClick={() => dispatch({ type: 'RESET' })}>Clear</button>
      </div>
    </div>
  )
}

function pointInPolygon(point: [number, number], geometry: GeoJSON.Geometry): boolean {
  // Implement Ray Casting algorithm (see GeoUtils documentation)
  // ...
}
```

---

## Summary

This guide covered:

1. **Advanced React patterns** for managing complex state and optimizing rendering
2. **Advanced TypeScript** for type safety and expressiveness
3. **Detailed GSI architecture** including tile coordinates, Web Mercator projection, tile services, and Kokuarea vector tiles
4. **Integration patterns** showing how GSI is used throughout this project
5. **Real-world example** combining multiple concepts

For further learning, refer to:
- [MapLibre GL JS Documentation](https://maplibre.org/maplibre-gl-js/docs/)
- [GSI Cyberjapan Tiles](https://maps.gsi.go.jp/development/ichiran.html)
- [Web Mercator Projection Details](https://en.wikipedia.org/wiki/Web_Mercator_projection)
- [GeoJSON Specification](https://tools.ietf.org/html/rfc7946)
