{/* GSIArchitecture.mdx */}
import { Meta } from '@storybook/blocks'

<Meta title="Learning/GSI Architecture" />

# GSI (Geospatial Information Authority) Architecture

Deep dive into Japan's national geospatial data infrastructure and how it's integrated into this project.

---

## Part 1: GSI Fundamentals

### 1.1 What is GSI?

The **Geospatial Information Authority of Japan (国土地理院)** is Japan's official national mapping organization. It provides free, high-quality geospatial data through:

- **Cyberjapan platform**: Tile-based mapping services
- **Kokuarea service**: Airport airspace boundary data
- **Elevation data**: Digital elevation models
- **Administrative boundaries**: Official territorial data

Key characteristics:
- Official, government-maintained data
- Free access (no API key required)
- High accuracy and regular updates
- Attribution required (must display "国土地理院")
- Coverage: All of Japan and surrounding areas

### 1.2 Why GSI Over Other Data Sources?

```
Comparison Matrix:

Feature          | GSI  | OSM  | Google | Bing
===============================================
Official status  | Yes  | No   | No     | No
Free access      | Yes  | Yes  | No     | No
Japan coverage   | 95%  | 80%  | 95%    | 90%
Real-time update | Yes  | User | Auto   | Auto
Attribution      | Yes  | Yes  | No     | Yes
Vector tiles     | Yes  | Yes  | Yes    | Yes
```

In this project, we use GSI as the primary data source for accuracy and reliability.

---

## Part 2: Tile Coordinate System (XYZ)

### 2.1 How XYZ Coordinates Work

Web maps use the **XYZ addressing system** to organize tiles. At each zoom level, the world is divided into a grid of square tiles.

```
Zoom Level 0: 1 × 1 = 1 tile (entire world)
Zoom Level 1: 2 × 2 = 4 tiles
Zoom Level 2: 4 × 4 = 16 tiles
Zoom Level 3: 8 × 8 = 256 tiles
Zoom Level z: 2^z × 2^z tiles
```

Each tile is identified by three coordinates:
- **z**: Zoom level (0-18 for GSI)
- **x**: Column (0 to 2^z - 1, west to east)
- **y**: Row (0 to 2^z - 1, north to south)

### 2.2 Longitude/Latitude to Tile Conversion

Converting geographic coordinates to tile coordinates:

```typescript
function lonLatToTile(
  lon: number,
  lat: number,
  z: number
): { x: number; y: number } {
  const n = Math.pow(2, z)
  
  // X: Simple linear conversion of longitude
  const x = Math.floor(((lon + 180) / 360) * n)
  
  // Y: Web Mercator projection of latitude
  const latRad = (lat * Math.PI) / 180
  const y = Math.floor(
    ((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2) * n
  )
  
  return { x, y }
}

// Example: Tokyo Station at zoom 10
const tile = lonLatToTile(139.7673, 35.6812, 10)
// Result: { x: 585, y: 402 }
```

Reverse conversion (tile to coordinates):

```typescript
function tileToLonLat(
  x: number,
  y: number,
  z: number
): [number, number] {
  const n = Math.pow(2, z)
  
  // Longitude: Direct inverse of x calculation
  const lon = (x / n) * 360 - 180
  
  // Latitude: Inverse Web Mercator
  const latRad = Math.atan(Math.sinh(Math.PI * (1 - (y / n) * 2)))
  const lat = (latRad * 180) / Math.PI
  
  return [lon, lat]
}

// Example: Get center of tile (585, 402) at zoom 10
const [lon, lat] = tileToLonLat(585.5, 402.5, 10)
// Result: [139.76..., 35.68...]
```

### 2.3 Project Implementation

This project uses these conversions in **kokuarea.ts** (lines 72-87):

```typescript
function toTileX(lon: number, z: number): number {
  const n = 2 ** z
  return Math.floor(((lon + 180) / 360) * n)
}

function toTileY(lat: number, z: number): number {
  const n = 2 ** z
  const latRad = (lat * Math.PI) / 180
  const y = (1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2
  return Math.floor(y * n)
}

// Calculate visible tiles in current map bounds
export function getVisibleTileXYZs(
  bounds: maplibregl.LngLatBounds,
  z: number
): Array<{ z: number; x: number; y: number }> {
  const west = bounds.getWest()
  const east = bounds.getEast()
  const south = bounds.getSouth()
  const north = bounds.getNorth()

  const xMin = toTileX(west, z)
  const xMax = toTileX(east, z)
  const yMin = toTileY(north, z)
  const yMax = toTileY(south, z)

  const tiles: Array<{ z: number; x: number; y: number }> = []
  for (let x = xMin; x <= xMax; x++) {
    for (let y = yMin; y <= yMax; y++) {
      tiles.push({ z, x, y })
    }
  }
  return tiles
}
```

---

## Part 3: Web Mercator Projection (EPSG:3857)

### 3.1 What is Web Mercator?

Web Mercator (EPSG:3857) is the standard projection for web maps. It projects the spherical Earth onto a flat square surface while maintaining angle relationships.

### 3.2 Why Web Mercator?

Advantages:
1. **Seamless tiles**: Tiles fit perfectly together at all zoom levels
2. **Square tiles**: Rectangular tiles would complicate rendering
3. **Zero distortion at equator**: Most detailed near equator where detail matters
4. **Conformal projection**: Preserves angles (important for navigation)

Disadvantages:
1. **Area distortion**: Increases toward poles (Greenland appears 4x larger)
2. **Cannot represent poles**: Singularity at ±90° latitude
3. **Not equal-area**: Not suitable for statistical mapping

### 3.3 Mathematical Model

```typescript
const EARTH_RADIUS = 6378137 // meters (WGS84 equatorial radius)

// Convert latitude/longitude to Web Mercator coordinates
function toMercator(lon: number, lat: number): { x: number; y: number } {
  const x = (lon * EARTH_RADIUS * Math.PI) / 180
  
  const latRad = (lat * Math.PI) / 180
  const y = EARTH_RADIUS * Math.log(Math.tan(Math.PI / 4 + latRad / 2))
  
  return { x, y }
}

// Reverse: Web Mercator to latitude/longitude
function fromMercator(x: number, y: number): [number, number] {
  const lon = (x * 180) / (EARTH_RADIUS * Math.PI)
  const lat = (Math.atan(Math.sinh(y / EARTH_RADIUS)) * 180) / Math.PI
  
  return [lon, lat]
}

// Example: Tokyo Station
const mercator = toMercator(139.7673, 35.6812)
// Result: { x: 15572254, y: 4281200 }

const [lon, lat] = fromMercator(15572254, 4281200)
// Result: [139.76..., 35.68...]
```

### 3.4 Projection Limits

GSI tiles are cut off at ±85.051129° latitude (the Web Mercator limit):

```typescript
const MERCATOR_MAX_LAT = 85.051129

// Clamp latitude values
function clampLatitude(lat: number): number {
  return Math.max(-MERCATOR_MAX_LAT, Math.min(lat, MERCATOR_MAX_LAT))
}

// Outside this range, tiles don't exist
const northPole = 90     // Can't display
const valid = 35.6812    // OK
const clamped = clampLatitude(northPole) // 85.05°
```

---

## Part 4: GSI Tile Services

### 4.1 Available Services

GSI provides multiple tile layers through the Cyberjapan platform:

<table>
  <thead>
    <tr>
      <th>Service</th>
      <th>URL Path</th>
      <th>Type</th>
      <th>Use Case</th>
      <th>Format</th>
      <th>Min Zoom</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Standard Map (標準)</td>
      <td>std/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>General purpose mapping</td>
      <td>PNG</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Pale Map (淡色地図)</td>
      <td>pale/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Light background for overlays</td>
      <td>PNG</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Aerial Photo (航空写真)</td>
      <td>seamlessphoto/{z}/{x}/{y}.jpg</td>
      <td>Raster</td>
      <td>Detailed aerial imagery</td>
      <td>JPEG</td>
      <td>10</td>
    </tr>
    <tr>
      <td>Hillshade (陰影起伏)</td>
      <td>hillshademap/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Terrain shading overlay</td>
      <td>PNG</td>
      <td>5</td>
    </tr>
    <tr>
      <td>Colored Relief (色別標高)</td>
      <td>relief/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Elevation visualization</td>
      <td>PNG</td>
      <td>5</td>
    </tr>
    <tr>
      <td>Slope Map (傾斜量図)</td>
      <td>slopemap/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Steep slope visualization</td>
      <td>PNG</td>
      <td>5</td>
    </tr>
    <tr>
      <td>DID 2015 (人口集中地区)</td>
      <td>did2015/{z}/{x}/{y}.png</td>
      <td>Raster</td>
      <td>Population density areas</td>
      <td>PNG</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Kokuarea (国家基盤)</td>
      <td>kokuarea/{z}/{x}/{y}.geojson</td>
      <td>Vector GeoJSON</td>
      <td>Airport airspace boundaries</td>
      <td>GeoJSON</td>
      <td>8</td>
    </tr>
    <tr>
      <td>Building Vectors (地物)</td>
      <td>experimental_bvmap/{z}/{x}/{y}.pbf</td>
      <td>Vector Protobuf</td>
      <td>Building footprints (experimental)</td>
      <td>PBF</td>
      <td>14</td>
    </tr>
  </tbody>
</table>

### 4.2 URL Template Pattern

All GSI tiles follow this URL structure:

```
https://cyberjapandata.gsi.go.jp/xyz/{service}/{z}/{x}/{y}.{format}
```

Parameters:
- `{service}`: Service identifier (std, pale, seamlessphoto, etc.)
- `{z}`: Zoom level (0-18)
- `{x}`: Tile X coordinate
- `{y}`: Tile Y coordinate
- `{format}`: File format (png, jpg, pbf, geojson)

**MapLibre automatically substitutes z, x, y** based on the current viewport:

```typescript
// In baseMaps.ts (line 23)
tiles: ['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png']

// MapLibre converts this to actual requests:
// https://cyberjapandata.gsi.go.jp/xyz/std/5/16/13.png
// https://cyberjapandata.gsi.go.jp/xyz/std/5/16/14.png
// etc. based on viewport
```

### 4.3 Raster vs Vector Tiles

**Raster Tiles** (PNG, JPG):
- Pre-rendered images
- Smaller file size (50-200KB per tile)
- No styling at client
- Fast to display
- Used by: Standard, Pale, Aerial, Hillshade, Relief, Slope, DID

**Vector Tiles** (GeoJSON, PBF):
- Geometric data + attributes
- Larger file size (vector GeoJSON: 20-100KB)
- Styled at client (MapLibre)
- Interactive (click, hover)
- Used by: Kokuarea, Building vectors

---

## Part 5: Kokuarea Vector Tiles

### 5.1 What is Kokuarea?

**Kokuarea** (国家基盤) provides GeoJSON vector tiles containing airport airspace boundaries defined by the Civil Aviation Bureau (CAAB).

Each feature represents an **airspace surface** around an airport:

- **進入表面** (Approach surface): Landing approach path
- **転移表面** (Transitional surface): Transition zone
- **水平表面** (Horizontal surface): Outer horizontal surface
- **円錐表面** (Conical surface): Cone-shaped outer boundary

### 5.2 Feature Structure

Each Kokuarea feature is a GeoJSON Feature with:

```json
{
  "type": "Feature",
  "properties": {
    "name": "成田国際空港-B'-進入表面",
    "description": "Approach surface for Narita International Airport",
    "airport_code": "NRT"
  },
  "geometry": {
    "type": "Polygon",
    "coordinates": [[[lon, lat], [lon, lat], ...]]
  }
}
```

### 5.3 Project Classification

**kokuarea.ts** provides `classifyKokuareaSurface()` to categorize features:

```typescript
export function classifyKokuareaSurface(props: Record<string, unknown>): {
  kind: KokuareaSurfaceKind
  label: string
} {
  const name = typeof props.name === 'string' ? props.name : ''
  const strings = [name, ...getAllStringValues(props)].join(' ')

  if (strings.includes('進入表面')) return { kind: 'approach', label: '進入表面' }
  if (strings.includes('転移表面')) return { kind: 'transitional', label: '転移表面' }
  if (strings.includes('水平表面')) return { kind: 'horizontal', label: '水平表面' }
  if (strings.includes('円錐表面')) return { kind: 'conical', label: '円錐表面' }
  
  return { kind: 'other', label: '空港周辺空域' }
}
```

### 5.4 Styling Kokuarea Features

Each surface type has distinct styling in **kokuarea.ts**:

```typescript
export const KOKUAREA_STYLE = {
  approach: {
    fillColor: '#4CAF50',       // Green
    lineColor: '#2E7D32',
    fillOpacity: 0.25,
    lineWidth: 1.2,
    label: '進入表面'
  },
  transitional: {
    fillColor: '#FFC107',       // Amber
    lineColor: '#FF8F00',
    fillOpacity: 0.22,
    lineWidth: 1.1,
    label: '転移表面'
  },
  horizontal: {
    fillColor: '#9C27B0',       // Purple
    lineColor: '#6A1B9A',
    fillOpacity: 0.2,
    lineWidth: 1.1,
    label: '水平表面'
  },
  conical: {
    fillColor: '#2196F3',       // Blue
    lineColor: '#1565C0',
    fillOpacity: 0.18,
    lineWidth: 1.0,
    label: '円錐表面'
  }
}
```

### 5.5 Performance Considerations

Vector tiles have different performance characteristics than raster:

```
Performance Analysis:

Network:
- Raster: 50-200KB per tile
- Vector: 20-100KB per tile
- Vector is smaller (better for bandwidth)

CPU:
- Raster: Minimal (just render image)
- Vector: Parse GeoJSON, apply styles, render
- Vector is more CPU-intensive

Memory:
- Raster: Discarded after rendering
- Vector: Kept in memory for interactions
- Vector accumulates as you zoom

Best Practice:
- Only load Kokuarea tiles above zoom 8
- Limit tiles to visible area (use bounds)
- Unload tiles when moving away
```

Optimization example:

```typescript
const visibleTiles = useMemo(() => {
  if (zoomLevel < 8) return [] // Skip at low zoom
  return getVisibleTileXYZs(mapBounds, zoomLevel)
}, [mapBounds, zoomLevel])
```

---

## Part 6: Attribution Requirements

### 6.1 Legal Requirement

GSI data requires proper attribution. This is not optional—it's a legal requirement.

**Attribution Link:**
```
国土地理院
https://maps.gsi.go.jp/development/ichiran.html
```

### 6.2 Implementation in Project

In **baseMaps.ts** (line 8):

```typescript
const GSI_ATTRIBUTION = '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">国土地理院</a>'
```

Used in every GSI tile source:

```typescript
const style: maplibregl.StyleSpecification = {
  sources: {
    gsi: {
      type: 'raster',
      tiles: ['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png'],
      tileSize: 256,
      attribution: GSI_ATTRIBUTION  // Required!
    }
  },
  // ...
}
```

MapLibre automatically displays this in the bottom-right corner of the map.

---

## Part 7: Zoom Level Definitions

### 7.1 Zoom Levels and Scale

GSI provides tiles at zoom levels 0-18:

<table>
  <thead>
    <tr>
      <th>Zoom Range</th>
      <th>Scale</th>
      <th>Coverage</th>
      <th>Use Case</th>
      <th>Tile Count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0-4</td>
      <td>World to Country</td>
      <td>Global overview</td>
      <td>Initial app view, world scale</td>
      <td>1 - 256</td>
    </tr>
    <tr>
      <td>5-8</td>
      <td>Prefecture to City</td>
      <td>Japan regional</td>
      <td>Flight planning, regional view</td>
      <td>1K - 65K</td>
    </tr>
    <tr>
      <td>9-12</td>
      <td>District to Block</td>
      <td>Detailed local</td>
      <td>Flight path details, obstacles</td>
      <td>262K - 16M</td>
    </tr>
    <tr>
      <td>13-15</td>
      <td>Building to Detail</td>
      <td>Close inspection</td>
      <td>Structure inspection, precision</td>
      <td>8M - 256M</td>
    </tr>
    <tr>
      <td>16-18</td>
      <td>Street to Property</td>
      <td>Maximum detail</td>
      <td>Street-level inspection</td>
      <td>256M - 4B</td>
    </tr>
  </tbody>
</table>

### 7.2 Project Defaults

In **baseMaps.ts** (line 57):

```typescript
export const DEFAULT_CENTER: [number, number] = [137.0, 36.5]  // Japan center
export const DEFAULT_ZOOM = 5  // Prefecture-level view

// Region-specific views
export const REGION_VIEWS = {
  japan: { center: [137.0, 36.5], zoom: 5 },
  ishikawa: { center: [136.5, 36.8], zoom: 9 },
  noto: { center: [136.876, 37.405], zoom: 11 }
}
```

---

## Part 8: MapLibre Integration

### 8.1 Creating a Raster Tile Layer

```typescript
const style: maplibregl.StyleSpecification = {
  version: 8,
  sources: {
    gsi: {
      type: 'raster',
      tiles: ['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png'],
      tileSize: 256,
      attribution: GSI_ATTRIBUTION
    }
  },
  layers: [
    {
      id: 'gsi-base',
      type: 'raster',
      source: 'gsi'
    }
  ]
}
```

### 8.2 Creating a Vector Tile Layer

```typescript
const style: maplibregl.StyleSpecification = {
  sources: {
    kokuarea: {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: [] // Populated dynamically
      }
    }
  },
  layers: [
    {
      id: 'kokuarea-approach',
      type: 'fill',
      source: 'kokuarea',
      filter: ['==', ['get', '__koku_kind'], 'approach'],
      paint: {
        'fill-color': '#4CAF50',
        'fill-opacity': 0.25
      }
    },
    {
      id: 'kokuarea-outline',
      type: 'line',
      source: 'kokuarea',
      paint: {
        'line-color': '#2E7D32',
        'line-width': 1.2
      }
    }
  ]
}
```

### 8.3 Dynamic Tile Loading

Implementing the tile loading pattern from this project:

```typescript
async function loadKokuareaTiles(
  bounds: maplibregl.LngLatBounds,
  zoom: number
): Promise<GeoJSON.FeatureCollection> {
  if (zoom < 8) return { type: 'FeatureCollection', features: [] }

  const tiles = getVisibleTileXYZs(bounds, Math.floor(zoom))
  const features: GeoJSON.Feature[] = []

  for (const tile of tiles) {
    const url = `https://maps.gsi.go.jp/xyz/kokuarea/${tile.z}/${tile.x}/${tile.y}.geojson`
    
    try {
      const response = await fetch(url)
      const geojson = await response.json()
      
      geojson.features.forEach(feature => {
        const classification = classifyKokuareaSurface(feature.properties)
        feature.properties.__koku_kind = classification.kind
        features.push(feature)
      })
    } catch (error) {
      console.warn(`Failed to load tile ${tile.z}/${tile.x}/${tile.y}`, error)
    }
  }

  return { type: 'FeatureCollection', features }
}
```

---

## Part 9: Adding Custom GSI Layers

### 9.1 Adding a Hillshade Overlay

```typescript
export const GEO_OVERLAYS: GeoOverlay[] = [
  {
    id: 'hillshade',
    name: '陰影起伏',
    tiles: ['https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png'],
    opacity: 0.4,
    category: 'geo',
    description: '陰影起伏図（地形の凹凸を陰影で強調）'
  }
]
```

When loaded into MapLibre:

```typescript
mapRef.current.addSource('hillshade', {
  type: 'raster',
  tiles: ['https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png'],
  tileSize: 256
})

mapRef.current.addLayer({
  id: 'hillshade-layer',
  type: 'raster',
  source: 'hillshade',
  paint: { 'raster-opacity': 0.4 }
})
```

### 9.2 Adding DID (Population Density) Layer

```typescript
{
  id: 'did-area',
  name: '人口集中地区',
  type: 'did',
  color: RESTRICTION_COLORS.did,
  opacity: 0.5,
  tiles: ['https://cyberjapandata.gsi.go.jp/xyz/did2015/{z}/{x}/{y}.png'],
  description: '人口集中地区（DID）- 国勢調査に基づく'
}
```

---

## Summary

GSI provides:
- **9 tile services** covering different aspects of Japan's geography
- **Free access** with no API key required
- **High quality** verified against official surveys
- **Multiple formats**: Raster (PNG/JPG) and Vector (GeoJSON/PBF)
- **Complete coverage** of Japan at zoom 0-18

The XYZ coordinate system and Web Mercator projection are fundamental to understanding how tiles are addressed and displayed. Kokuarea provides critical airspace boundary data for flight planning.

For more information:
- [GSI Cyberjapan Tiles Documentation](https://maps.gsi.go.jp/development/ichiran.html)
- [MapLibre GL JS Documentation](https://maplibre.org/maplibre-gl-js/docs/)
- [GeoJSON Specification](https://tools.ietf.org/html/rfc7946)
